<h1>Service Workers: The easy and the hard way</h1>
<p>Service Workers are awesome. They give you a performance boost and the capability of limited offline work without having to create apps for each platfomt that we want to use our app in.</p>
<p>Service workers are the core of PWAs (Progressive Web Applications) where we take advantage of a set of web technologies to make apps that work closer to how native apps would.</p>
<p>We’ll concentrate on the service worker and in using Workbox.js and vanilla Javascript to create the service worker. I’ve chosen to go with Workbox first because the abbstraction makes it easier to create the type of abstractions I need.</p>
<p>Once I have a working service worker I will try to duplicate the functionality without libraries to compare how easy/hard it is.</p>
<h2>Registering the service worker</h2>
<p>We register the worker on page load to improve performance. This will work the same whether we’re using a vanilla Javascript service worker or if we implement it using Workbox.</p>
<p>Place the following script tag in the main page of your site or application.</p>
<pre><code class="language-html">&lt;script&gt;
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () =&gt; {
      navigator.serviceWorker.register('./sw.js');
      console.log('Service Worker registered');
    });
  }
&lt;/script&gt;
</code></pre>
<h2>Workbox.js</h2>
<p>Workbox is a libbrbary from Google that automates the creation of a service worker and hides a lot of the complexities inherent in the service worker creation.</p>
<p>This particular service worker is optimized for performance. We want to cache all the resource and either serve them from the catch falling back to the network or serving cached content while, at the same time, fetching the asset from the network and placing it in the cache for future use.</p>
<h3>Defining Items to Precache</h3>
<p>We have an external configuration file to run Workbox precaching. We’ll talk about the command at the end of the section.</p>
<p>The config file (<code>workbox.config.js</code>) tells us the following things:</p>
<ul>
<li>The source file for the service worker (<code>swSrc</code>)</li>
<li>The destinatioon for the service worker (<code>swDest</code>)</li>
<li>The root for the files we want to precache (<code>globDirectory</code>)</li>
<li>The list of files to precache (<code>globPatterns</code>)</li>
</ul>
<pre><code class="language-js">module.exports = {
  'swSrc': 'js/sw.js',
  'swDest': 'sw.js',

  'globDirectory': '.',
  'globPatterns': [
    'index.html',
    'css/index.css',
    'js/zenscroll.js',
    'pages/404.html',
    'pages/offline.html',
  ],
};
</code></pre>
<h3>Workbox Handlers</h3>
<p>I’ve chosen to decouple the routing and the strategies for each type of content that I want to cache.</p>
<p>The first type of content creates the <code>content-cache</code> cache where we will later store cached HTML content</p>
<pre><code class="language-js">// Cache strategies definitions
// HTML caching strategy
const contentHandler = workbox.strategies.cacheFirst({
  cacheName: 'content-cache',
});
</code></pre>
<p>The CSS handler will hold our stylesheets, both local and third party, to style the content.</p>
<p>The CSS cache does a couple special things via Workbox plugins:</p>
<ul>
<li>It accepts opaque responses for third party resources that wouldn’t normally be cached
<ul>
<li>It uses the <a href="https://developers.google.com/web/tools/workbox/reference-docs/latest/workbox.cacheableResponse.Plugin">cacheableResponse</a> plugin</li>
<li>The status code ‘0’ represents opaque responses</li>
</ul>
</li>
<li>It sets an expiration date to 14 days</li>
<li>It sets the maximum number of items the cache will hold. When the cache is full new entries will push the oldest out of the cache (and delete them)</li>
</ul>
<p>We cache opaque responses at our own risk since we have no way of knowing if the request succeeded or not.  I considered the risk and accepted it because the networks where I’m pulling third party resources from are big and stable (Cloudflare and Google Fonts).</p>
<p>In a future iteration I may want to move third party CSS resources to its own cache like I do with fonts, but I haven’t been able to figure out how to.</p>
<pre><code class="language-js">// CSS caching strategy
const cssHandler = workbox.strategies.cacheFirst({
  cacheName: 'css-cache',
  plugins: [
    new workbox.cacheableResponse.Plugin({
      statuses: [0, 200],
    }),
    new workbox.expiration.Plugin({
      maxAgeSeconds: 60 * 60 * 24 * 14,
      maxEntries: 30,
    }),
  ],
});
</code></pre>
<p>The Javascript handler will hold our local and third party scripts.</p>
<p>The cache does a couple special things via Workbox plugins:</p>
<ul>
<li>It accepts opaque responses for third party resources that wouldn’t normally be cached
<ul>
<li>It uses the <a href="https://developers.google.com/web/tools/workbox/reference-docs/latest/workbox.cacheableResponse.Plugin">cacheableResponse</a> plugin</li>
<li>The status code ‘0’ represents opaque responses</li>
</ul>
</li>
<li>It sets an expiration date to 14 days</li>
<li>It sets the maximum number of items the cache will hold. When the cache is full new entries will push the oldest out of the cache (and delete them)</li>
</ul>
<p>We cache opaque responses at our own risk since we have no way of knowing if the request succeeded or not.  I considered the risk and accepted it because the networks where I’m pulling third party resources from are big and stable (Cloudflare and Google Fonts)</p>
<p>In a future iteration I may want to move third party JS resources to its own cache like I do with fonts, but I haven’t been able to figure out how to.</p>
<pre><code class="language-js">const jsHandler = workbox.strategies.staleWhileRevalidate({
  cacheName: 'scripts-cache',
  plugins: [
    new workbox.cacheableResponse.Plugin({
      statuses: [0, 200],
    }),
    new workbox.expiration.Plugin({
      maxAgeSeconds: 60 * 60 * 24 * 14,
      maxEntries: 30,
    }),
  ],
});
</code></pre>
<p>As a performance improvement one of the best things I can think about doing is caching images so we only take the hit on the large download the first time that we download an image. Not saying we don’t need to optimize them but want to make sure that images load as fast as possible and that means that we should load them from cache if possible.</p>
<pre><code class="language-js">const imageHandler = workbox.strategies.cacheFirst({
  cacheName: 'image-cache',
  plugins: [
    new workbox.expiration.Plugin({
      // Cache for a maximum of 30 days
      maxAgeSeconds: 60 * 60 * 24 * 30,
    }),
  ],
});
</code></pre>
<p>Fonts will be the largest assets we cache with the service worker so we want to keep a few around and keep them for a while so we don’t have to download them as often. This is particularly important because the primary font, Roboto variable font, is 1MB in size when compressed as a woff2 font.</p>
<p>We’re keeping 5 locally hosted fonts (ones that are not served through Google fonts) and keeping them for 30 days although I may want to cache them longer and keep more of them, particularly if I work with smaller font subsets.</p>
<pre><code class="language-js">const fontHandler = workbox.strategies.cacheFirst({
  cacheName: 'fonts-cache',
  plugins: [
    new workbox.expiration.Plugin({
      maxAgeSeconds: 30 * 24* 60 * 60,
      maxEntries: 5,
    }),
  ],
});
</code></pre>
<p>External resources present an interesting problem when working with service workers. All responses from third party resources up vote are ‘opaque’ responses and represent the result of a request made to a remote origin when CORS is not enabled.</p>
<p>Caching opaque request makes it imposible for Workbox to detect and warn you if the request failed (there is no status code to tell it, and you, that it failed).</p>
<p>Workbox will cache opaque resources when using uses <code>networkFirst</code> or <code>staleWhileRevalidate</code> as the strategy. Both of this strategies will query the network first (<code>networkFirst</code>) or will query the network regardless of success or failure (<code>staleWhileRevalidate</code>)</p>
<p>To make sure that the resources are cached we use the <a href="https://developers.google.com/web/tools/workbox/reference-docs/latest/workbox.cacheableResponse.Plugin">cacheableResponse</a> plugin to tell Workbox that we want it to cache resources with a status code of <code>0</code>, regardless of the strategy we use.</p>
<pre><code class="language-js">const extFontHandler = workbox.strategies.cacheFirst({
  cacheName: 'external-fonts',
  plugins: [
    new workbox.expiration.Plugin({
      maxAgeSeconds: 30 * 24 * 60 * 60,
      maxEntries: 5,
    }),
    new workbox.cacheableResponse.Plugin({
      statuses: [0, 200],
    }),
  ],
});
</code></pre>
<h3>Defining routes</h3>
<p>The next step is to create routes that will use the strategies we just defined to cache the content and, where appropriate, provide fallback options.</p>
<p>These routes use Workbox routing and its <code>registerRoute</code> method to associate a file or extension, a handler (defined above) and zero or more additional conditions for each route.</p>
<p>I’ve broken he routes based on content and, where appropriate, on referring source.</p>
<p>The first type of resource that we cache outside of the precache. We make sure that there is a response and then do one of three things:</p>
<ul>
<li>If there is no response then provide an offline page</li>
<li>If the page is not found then return a 404 page</li>
<li>If there is an error then give the user an error page</li>
</ul>
<pre><code class="language-js">// Routing Definitions and Fallbacks
workbox.routing.registerRoute(/.*\.html/, (args) =&gt; {
  return contentHandler.handle(args)
    .then((response) =&gt; {
      if (!response) {
        return caches.match('pages/offline.html');
      } else if (response.status === 404) {
        return caches.match('pages/404.html');
      }
      return response;
    })
    .catch((response) =&gt; {
      return caches.match('pages/error.html');
    });
});
</code></pre>
<p>Next, we handle CSS requests and match them to the CSS extension. If there is no response or the response status is 404 we return nothing.</p>
<p>If there is an error we return nothing.</p>
<p>With CSS I don’t want to store anything in the cache that is not CSS unlike what we did with HTML where we wanted different responses for each event.</p>
<pre><code class="language-js">//  CSS other than index.css
workbox.routing.registerRoute(/.*\.css/, (args) =&gt; {
  return cssHandler.handle(args)
    .then((response) =&gt; {
      if (!response || response.status === 404) {
        return;
      }
      return response;
    })
    .catch((response) =&gt; {
      return;
    });
});
</code></pre>
<p>The route that handles Javascript uses the handler we defined earlier without any major adjustments. If the route is not OK it’ll produce an error which is what we want. Javascript failuers will usually render the site or app unusable.</p>
<pre><code class="language-js">// JS other than index.js and any JSON file
workbox.routing.registerRoute(/.*\.js/, (args) =&gt; {
  return jsHandler.handle(args);
});
</code></pre>
<p>When caching fonts we want to make sure that the browser caches all font formats that we may want to use (even though we only use woff2 fonts locally) to give ourselves the flexibility of using other formats without having to change the route later.</p>
<p>This will only cache local fonts, not those loaded from Google Fonts; we’ll handle third party fonts in a different route.</p>
<pre><code class="language-js">// Fonts
workbox.routing.registerRoute(/.*\.(?:ttf|otf|woff|woff2)/, (args) =&gt; {
  return fontHandler.handle(args);
});
</code></pre>
<p>This route will handle fonts loaded from Google Fonts. The URL may bbe <code>fonts.googleapis</code> or <code>fonts.gstatic</code> so we create a new regular expression that matches both sites and stores the fonts in a different cache than our local fonts.</p>
<pre><code class="language-js">// Third party fonts
workbox.routing.registerRoute(/^https:\/\/fonts\.(googleapis|gstatic)\.com/, (args) =&gt; {
  return extFontHandler.handle(args);
});
</code></pre>
<p>When we look at images we need to make sure that we’re caching all the kinds of images that we plan on using.</p>
<p>The route we’re creating includes all image formats except<a href="https://developers.google.com/speed/webp/">WebP</a> since it’s not widely supported but we include both GIF and SVG.</p>
<pre><code class="language-js">// Images.
workbox.routing.registerRoute(/.*\.(?:png|jpg|jpeg|svg|gif)/, (args) =&gt; {
  return imageHandler.handle(args);
});
</code></pre>
<h3>Injecting the pre-cache items</h3>
<p>The final step is to incorporate the precache files that we defined in <code>workbox-config.js</code> into the service worker file.</p>
<p>The command requires you to install the workbox node module globally</p>
<pre><code class="language-sh">npm install workbox-cli --global
</code></pre>
<p>The module makes the <code>workbox</code>  command available on the terminal. Once installed, run the following command to inject the files we want to precache into the service worker.</p>
<pre><code class="language-sh">workbox injectManifest workbox-config.js
</code></pre>
<h3>Additional Enhancements</h3>
<p>There are a few things that I’m working on beyond the service worker that we described in the previous sections.</p>
<h4>Local Videos</h4>
<p>We are still using animated GIFs to create animations and demos. We may be able to <a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/replace-animated-gifs-with-video/">create smaller animations using MP4 video instead of GIF</a> but until we do the GIF images stay in this cache. We’ll use the video cache to store any other videos that we download locally, not from Youtube or Vimeo.</p>
<pre><code class="language-js">const videoHandler = workbox.strategies.cacheFirst({
  cacheName: 'videos-cache',
  plugins: [
    new workbox.expiration.Plugin({
      maxAgeSeconds: 180 * 24 * 60 * 60,
    }),
  ],
});
</code></pre>
<p>The route will match 4 types of video: WebM, MP4, OGG and AV1. These videos will download locally, not from Youtube or Vimeo. We’ll handle that in a different route</p>
<pre><code class="language-js">// videos.
workbox.routing.registerRoute(/.*\.(?:webm|mp4|ogg|mkv)/, (args) =&gt; {
  return videoHandler.handle(args);
});
</code></pre>
<h4>Third Party Videos</h4>
<p>The previous route handles video loaded using the <code>video</code> tag hosted locally and using one of the formats that are common for HTML video.</p>
<p>The problem is that this may be too quick to fill out the storage quota for the domain. I’m still torn between using this strategy that will load from cache and then fall back to the network and using a netowrk only strategy to save bandwidth and disk space.</p>
<pre><code class="language-js">const extVideoHandler = workbox.strategies.cacheFirst({
  cacheName: 'external-video',
    plugins: [
      new workbox.expiration.Plugin({
        maxAgeSeconds: 180 * 24 * 60 * 60,
      }),
      new workbox.cacheableResponse.Plugin({
        statuses: [0, 200],
      }),
    ],
});
</code></pre>
<p>The regular expression used in this route matches the pages and the embeds for both Vimeo and Youtube.</p>
<pre><code class="language-js">workbox.routing.registerRoute(/^(https:\/\/)
(player\.vimeo.com|www\.youtube\.com)
\/([\w\/]+)([\?].*)?$/, (args) =&gt; {
  return extVideoHandler(args);
});
</code></pre>
<p>Because the regular expression is more complex than I’m used to I’ve chosen to document it to make sure that I remember what it’s supposed to do.</p>
<ul>
<li><code>^</code> asserts position at start of a line</li>
<li>1st Capturing Group (https://)
<ul>
<li><code>https:</code> matches the characters https: literally (case sensitive)</li>
<li><code>\/</code> matches the character / literally (case sensitive)</li>
<li><code>\/</code> matches the character / literally (case sensitive)</li>
</ul>
</li>
<li>2nd Capturing Group <code>(player\.vimeo.com|vimeo\.com|www\.youtube\.com)</code></li>
<li>1st Alternative <a href="http://player.vimeo.com">player.vimeo.com</a>
<ul>
<li><code>player</code> matches the characters player literally (case sensitive)</li>
<li><code>\.</code> matches the character . literally (case sensitive)</li>
<li><code>vimeo</code> matches the characters vimeo literally (case sensitive)</li>
<li><code>.</code> matches any character (except for line terminators)</li>
<li><code>com</code> matches the characters com literally (case sensitive)</li>
</ul>
</li>
<li>2nd Alternative <code>vimeo\.com</code>
<ul>
<li><code>vimeo</code> matches the characters vimeo literally (case sensitive)</li>
<li><code>\.</code> matches the character . literally (case sensitive)</li>
<li><code>com</code> matches the characters com literally (case sensitive)</li>
</ul>
</li>
<li>3rd Alternative <code>www\.youtube\.com</code>
<ul>
<li><code>www</code> matches the characters www literally (case sensitive)</li>
<li><code>\.</code> matches the character . literally (case sensitive)</li>
<li><code>youtube</code> matches the characters youtube literally (case sensitive)</li>
<li><code>\.</code> matches the character . literally (case sensitive)</li>
<li><code>com</code> matches the characters com literally (case sensitive)</li>
<li><code>\/</code> matches the character / literally (case sensitive)</li>
</ul>
</li>
<li>3rd Capturing Group <code>([\w\/]+)</code>
<ul>
<li>Match a single character present in the list below [\w/]+</li>
<li><code>+</code> Quantifier — Matches between one and unlimited times, as many times as possible, giving back as needed (greedy)</li>
<li><code>\w</code> matches any word character (equal to [a-zA-Z0-9_])</li>
<li><code>\/</code> matches the character / literally (case sensitive)</li>
</ul>
</li>
<li>4th Capturing Group ([?].*)?
<ul>
<li><code>?</code> Quantifier — Matches between zero and one times, as many times as possible, giving back as needed (greedy)</li>
<li>Match a single character present in the list below [?]</li>
<li><code>\?</code> matches the character ? literally (case sensitive)</li>
<li><code>.*</code> matches any character (except for line terminators)</li>
<li><code>$</code> asserts position at the end of a line</li>
</ul>
</li>
</ul>
<h2>“Vanilla” Javascript, no libraries</h2>
<p>The idea is to create the service worker using only native APIs and seeing how much of the Workbox functionality I can duplicate without having to use a library.</p>
<h3>Constants and common items</h3>
<p>Individual constants for each of the caches. We store them separately so we can change the names to make cleanup easier without having to change the array we define later.</p>
<pre><code class="language-js">
const PRECACHE = 'precache-v1';
const CONTENT = 'content-cache-v1';
const CSS = 'css-cache-v1';
const JS = 'scripts-cache-v1';
const IMAGES = 'image-cache-v1';
const FONTS = 'fonts-cache-v1';
</code></pre>
<p>expectedCaches is the array of cache names we expect to exists in the client.</p>
<p>If they don’t we’re fine, we fetch from network; If they do, we’re fine, we fetch from cache and if they exist with a different version then we delete the old one</p>
<pre><code class="language-js">const expectedCaches = [
  PRECACHE,
  CONTENT,
  CSS,
  JS,
  IMAGES,
  FONTS,
];
</code></pre>
<p><code>urlsToPrecache</code> is the list of URLs that we want to cache on install. The <code>/</code> URL indicates the root file, in this case, index.html</p>
<pre><code class="language-js">const urlsToPrecache = [
  '/index.html',
  '/css/index.css',
  '/js/zenscroll.js',
  '/404.html',
  '/offline.html',
];
</code></pre>
<h3>Install Event</h3>
<p>The install event will take all the URLs in the <code>urlsToPrecache</code> array</p>
<pre><code class="language-js">self.addEventListener('install', (event) =&gt; {
  self.skipWaiting();
  console.log('install event fired');
  event.waitUntil(caches.open(PRECACHE).then((precache) =&gt; {
    return precache.addAll(urlsToPrecache);
  })); // ends wait until
}); // ends install event
</code></pre>
<h3>Activate Event</h3>
<p>Activate will perform cleanup on the caches.</p>
<p>If there is a cache that doesn’t exist in the Array that we pass to the event then it’s deleted This is the reason why we went through such a convoluted way to define the caches. We can change the names individually and then they’ll get deleted the next time the user visits the site.</p>
<pre><code class="language-js">self.addEventListener('activate', (event) =&gt; {
  clients.claim();
  event.waitUntil(
  caches.keys().then((keys) =&gt; {
    Promise.all(keys.map((key) =&gt; {
      // if the cache is not one in the list
      if (!expectedCaches.includes(key)) {
        // delete it
        return caches.delete(key);
      }
    }))
    .then(() =&gt; {
      console.log('Everything cleaned up');
    });
  }));
});
</code></pre>
<h3>Fetch Event</h3>
<p>The fetch event is where most of the work will happen. Unlike the work in Workbox service worker we don’t break the routes into different blocks in the vanilla service worker.</p>
<p>There are some aspects where the vanilla service worker still doesn’t match the Workbox implementation.</p>
<p>All the following sections are inside the fetch event listener. I’ve broken them down for ease of reading.</p>
<p>This is an important item to remember for all fetch handlers that put resources in caches using the cache API:</p>
<p><em><strong>Put a copy of the response in the cache, otherwise the code will throw an exception because response is a stream that can only be consumed once</strong></em></p>
<p>When we define the event we do two things right away:</p>
<p>We define a constant to hold the vaslues of the event’s request object.</p>
<p>If the request doesn’t match the <code>GET</code> HTTP method we return without doing anything. The service worker will only work with GET requests.</p>
<pre><code class="language-js">self.addEventListener('fetch', (event) =&gt; {
  const request = event.request;

  if (request.method !== 'GET') {
    return;
  }
</code></pre>
<p>The first handler is for fonts. Since the fonts are requested from the <code>typography-*.css</code> stylesheets I have to make sure that the font is loaded from the stylesheet or that the file ends in one of the four font formats I work with.</p>
<pre><code class="language-js">  if (request.url.match(/\.(ttf|otf|woff|woff2)$/) ||
    (request.referrer.includes('typography'))) {
    event.waitUntil(
      // Open the fonts cache
      caches.open(FONTS)
        .then((cache) =&gt; {
          // return the font to the user
          return cache.match(request);
        })
        .then((response) =&gt; {
          // Open the cache
          caches.open(FONTS)
          .then((cache) =&gt; {
            // Fetch the resource from the network
            return fetch(request)
            .then((response) =&gt; {
              // Put a copy of the resource in the cache
              return cache.put(request, response.clone())
              .then(() =&gt; {
                return response;
              });
            });
          });
        })
    );
  }
</code></pre>
<p>Caching Javascript resources has a different objective: To cache all the Javascript files that are not in the install precache. The match query means include all files with a <code>.js</code> extension except one that includes <code>zenscroller</code> in the URL (Zenscroller is cached at install).</p>
<pre><code class="language-js">  if (request.url.match(/\.(js)$/) &amp;&amp; (!request.url.includes('zenscroll'))) {
    event.waitUntil(
      caches.open(JS)
      .then((cache) =&gt; {
        return cache.match(request);
      })
      .then((response) =&gt; {
        caches.open(JS)
        .then((cache) =&gt; {
          fetch(request)
          .then((response) =&gt; {
            return cache.put(request, response.clone())
              .then(() =&gt; {
                // Return the response
                return response;
              });
          });
        });
      })
    );
    return;
  }
</code></pre>
<p>For CSS we want to make sure we cache all files with a <code>.css</code> extension and that are not fonts (denoted by a <code>.woff2</code> extension).</p>
<pre><code class="language-js">  // two places. Working on figuring out a solution
  if (request.url.match(/\.(css)$/) &amp;&amp;
    !request.url.includes('woff2')) {
    event.waitUntil(
      // Open the content cache
      caches.open(CSS)
        .then((cache) =&gt; {
          // return the CSS to the user
          return cache.match(request);
        })
        .then((response) =&gt; {
          // Open the cache
          return caches.open(CSS)
          .then((cache) =&gt; {
            // Fetch the resource from the network
            fetch(request).then((response) =&gt; {
              // Put a copy of the response in the cache
              return cache.put(request, response.clone())
              .then(() =&gt; {
                // Return the response
                return response;
              });
            });
          });
        })
    );
    return;
  }
</code></pre>
<p>In the cache for images we want to make sure that we add only images only (those that match <code>jpeg</code>, <code>jpg</code>, <code>png</code>, <code>gif</code> and <code>svg</code>) and not the assets that reference the images (HTML and CSS).</p>
<p>If the image is not in the cache and we can’t retrieve it from the network we provide a local fallback as a new response using an SVG image.</p>
<pre><code class="language-js">  if (request.url.match(/\.(jpe?g|png|gif|svg)$/) &amp;&amp;
    (!request.url.match('/\.(html|css)$/'))) {
    event.waitUntil(
      caches.open(IMAGES)
      .then((cache) =&gt; {
        // return the IMAGES to the user
        return caches.match(request);
      })
      .then((response) =&gt; {
        // Open the cache
        return caches.open(IMAGES)
        .then((cache) =&gt; {
          // Fetch the resource from the network
          fetch(request)
          .then((response) =&gt; {
            // Put a copy of the response in the cache
            return cache.put(request, response.clone())
            .then(() =&gt; {
              // Return the response
              return response;
            });
          })
          .catch((error) =&gt; {
            return new Response(OFFLINESVG, {
              headers: {
                'Content-Type': 'image/svg+xml',
              },
            });
          });
        });
      })
    );
    return; // If we get to here, bail out
  }
</code></pre>
<p>The final handler for assets is for HTML content by using a stale while revalidate strategy, we return the resource in the cache, if it’s not in the cache then we fetch it from the network, store a copy of the response in the cache and return the resource to the user.</p>
<p>In this cache we could be more sophisticated and return different responses based on whether we’re offline, the resource was not found or any other network failure. But for an MVP, this is enough.</p>
<pre><code class="language-js">  if (event.request.headers.get('Accept')
    .includes('text/html')) {
    // Open the content cache
    caches.open(CONTENT)
    .then((cache) =&gt; {
      // return the content to the user
      return caches.match(request);
    })
    .then((response) =&gt; {
      // Open the cache
      caches.open(CONTENT)
      .then((cache) =&gt; {
        // Fetch the resource from the network
        fetch(request)
        .then((response) =&gt; {
          // Put a copy of the response in the cache
          cache.put(request, response.clone())
          .then(() =&gt; {
            // Return the response
            return response;
          });
        });
      });
    });
  }
});
</code></pre>
