<h1>Node and HTTP/2</h1>
<p>HTTP/2 is the later evolution of the HTTP protocol that powers the web. It’s main goal is to improve performance and latency over existing HTTP 1.1 implementations. For more details see Ilyia Gregorik’s High Performance Browser Networking <a href="https://hpbn.co/http2/">chapter on HTTP/2</a></p>
<p>HTTP/2 landed in Node.js 8.4 behind a flag. With Node.js 9, it became an experimental part of Node core, still at stability 1. This is the version we’ll be working with. Do not run production workloads using this API yet, since it might change. Check the Node HTTP/2 API documentation for more information</p>
<h2>Getting an SSL certificate for localhost</h2>
<aside class="message warning">
  <p>While it's possible use HTTP/2 without TSL no current browser supports it. If you want to serve content through HTTP/2 to web browsers you must do it securely through HTTPS.</p>
</aside>
<p>To run the example above, you have to generate a private key and a certificate for your server. To do so, run this command:</p>
<pre><code class="language-bash">openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -keyout key.pem -out cert.pem
</code></pre>
<p>When it asks for the common name, make sure to enter <code>localhost</code>.</p>
<p>We will use these keys in the following examples.</p>
<p><strong>Do not use self-signed keys in production servers!</strong> For production servers you can purchase a certificate or use <a href="https://letsencrypt.org/">let’s encrypt</a> to generate free certificates.</p>
<p>Also be aware the most browsers will indicate that the site is insecure. You can safely ignore this warning if you’re working on your local development machine.</p>
<h2>Basic Server Example</h2>
<p>The most basic example using this API will serve a stream to the client.</p>
<p>We first require the necessary modules. Because both of them are part of the core Node.js system we don’t need to install them.</p>
<pre><code class="language-javascript">const http2 = require('http2')
const fs = require('fs')
</code></pre>
<p>Next, we creaate our securre server. We pass two parameters that are read synchronously: the location of our SSL key and certificate. We do it synchronously because we need the read to be complete before we move forward with the rest of the process.</p>
<pre><code class="language-javascript">const server = http2.createSecureServer({
  key: fs.readFileSync('./key.pem'),
  cert: fs.readFileSync('./cert.pem')
})
</code></pre>
<p>Remember that this is a low level API. We’re working through a connection between a <a href="https://nodejs.org/api/http2.html#http2_class_http2secureserver">http2SecureServer</a> object and one underlying socket.</p>
<p>We listen for three events between the socket and the server:</p>
<ul>
<li><a href="https://nodejs.org/api/http2.html#http2_event_error">error</a>: Happens when an error occurs during the processing of an Http2Session</li>
<li><a href="https://nodejs.org/api/http2.html#http2_event_socketerror">sockerError</a>: Triggered when an ‘error’ is emitted on the Socket instance bound to the Http2Session. If this event is not handled, the ‘error’ event will be re-emitted on the Socket</li>
<li><a href="https://nodejs.org/api/http2.html#http2_event_stream">stream</a>: fired when a new Http2Stream is created. When invoked, the handler function will receive a reference to the Http2Stream object, a Headers Object, and numeric flags associated with the creation of the stream</li>
</ul>
<p>The stream will respond with the content type of the response, the status code and the payload of the response. Because the stream is a Duplex, read and write enabled, we use the end property to write our content. See the description of the writable stream’s <a href="https://nodejs.org/api/stream.html#stream_writable_end_chunk_encoding_callback">end method</a> for more information and to see what additional tricks you have at your disposal.</p>
<pre><code class="language-javascript">server.on('error', (err) =&gt; console.error(err))
server.on('socketError', (err) =&gt; console.error(err))
server.on('stream', (stream, headers) =&gt; {
  // stream is a Duplex
  stream.respond({
    'content-type': 'text/html',
    ':status': 200
  })
  stream.end('&lt;h1&gt;Hello World&lt;/h1&gt;')
})
</code></pre>
<p>The final task is to set the server to listen in the specified port. In a production environment I would put the value for the port in a configuration file or in <code>package.json</code></p>
<pre><code class="language-javascript">server.listen(7300)
</code></pre>
<h2>Static File Server</h2>
<aside class="message info">
<p>This file server is taken from <a href="https://dexecure.com/blog/how-to-create-http2-static-file-server-nodejs-with-examples/">How to create a zero dependency HTTP/2 static file server with Node.js (with examples)</a></p>
</aside>
<p>As usual we require the files that we need. <code>mime-types</code> is not part of core Node so you must install with with npm (<code>npm i mime-types</code>) before continuing.</p>
<pre><code class="language-javascript">const http2 = require('http2');
const fs = require('fs');
const path = require('path');
const mime = require('mime-types');
</code></pre>
<p>The next block of code handles configuration of the server.</p>
<ul>
<li>We define <a href="https://nodejs.org/api/http2.html#http2_http2_constants">http2.constants</a> to make it easier to work with error codes.</li>
<li>Next, we create an object holding the location of the certificate and key</li>
<li>We set up the server using the options object as a parameter</li>
<li>The location of the server root; in this case the <code>public</code> directory.</li>
</ul>
<pre><code class="language-javascript">const {
  HTTP2_HEADER_PATH,
  HTTP2_HEADER_METHOD,
  HTTP_STATUS_NOT_FOUND,
  HTTP_STATUS_INTERNAL_SERVER_ERROR
} = http2.constants;

const options = {
  key: fs.readFileSync('./key.pem'),
  cert: fs.readFileSync('./cert.pem')
}

const server = http2.createSecureServer(options);

const serverRoot = &quot;./public&quot;;
</code></pre>
<p><code>respondToStreamError</code> is a functions that will handle 400 (<code>HTTP_STATUS_NOT_FOUND</code>) and 500 (<code>HTTP_INTERNAL_SERVER_ERROR</code>) error codes.</p>
<pre><code class="language-javascript">function respondToStreamError(err, stream) {
  console.log(err);
  if (err.code === 'ENOENT') {
      stream.respond({ &quot;:status&quot;: HTTP_STATUS_NOT_FOUND });
  } else {
      stream.respond({ &quot;:status&quot;: HTTP_STATUS_INTERNAL_SERVER_ERROR });
  }
  stream.end();
}
</code></pre>
<p>The stream method is where we make all the changes.  We first set up variables to hold the following information about the request</p>
<ul>
<li>Request Path</li>
<li>Request Method</li>
<li>The full path to the requested item</li>
<li>The mime type of the objject we’re responding with</li>
</ul>
<p>We then use <code>respondWithFile</code> to return the file with the appropriate mime type and use <code>respondToStreamError</code> to provide an error if appropriate.</p>
<pre><code class="language-javascript">server.on('stream', (stream, headers) =&gt; {
  const reqPath = headers[HTTP2_HEADER_PATH];
  const reqMethod = headers[HTTP2_HEADER_METHOD];

  const fullPath = path.join(serverRoot, reqPath);
  const responseMimeType = mime.lookup(fullPath);

  stream.respondWithFile(fullPath, {
      'content-type': responseMimeType
  }, {
      onError: (err) =&gt; respondToStreamError(err, stream)
  });
});
</code></pre>
<p>As always we listen in the specified port.</p>
<pre><code class="language-javascript">server.listen(7350);
</code></pre>
<h2>Pushing Resources:  Push</h2>
<p>One of the best new features, and one that is very hard to use correctly, is server push. The idea is that, if we know that the current page or another page on the site will use a resource, we can have the server push the resource to the browser before it requests it.</p>
<p>The configuration and <code>respondToStreamError</code> are the same as the static file server.</p>
<pre><code class="language-javascript">const http2 = require('http2');
const fs = require('fs');
const path = require('path');
const mime = require('mime-types');

const {
  HTTP2_HEADER_PATH,
  HTTP2_HEADER_METHOD,
  HTTP_STATUS_NOT_FOUND,
  HTTP_STATUS_INTERNAL_SERVER_ERROR
} = http2.constants;

const options = {
  key: fs.readFileSync('./key.pem'),
  cert: fs.readFileSync('./cert.pem')
}

const server = http2.createSecureServer(options);

const serverRoot = &quot;./public&quot;;

function respondToStreamError(err, stream) {
  console.log(err);
  if (err.code === 'ENOENT') {
      stream.respond({ &quot;:status&quot;: HTTP_STATUS_NOT_FOUND });
  } else {
      stream.respond({ &quot;:status&quot;: HTTP_STATUS_INTERNAL_SERVER_ERROR });
  }
  stream.end();
}

server.on('stream', (stream, headers) =&gt; {
  const reqPath = headers[HTTP2_HEADER_PATH];
  const reqMethod = headers[HTTP2_HEADER_METHOD];

  const fullPath = path.join(serverRoot, reqPath);
  const responseMimeType = mime.lookup(fullPath);
</code></pre>
<p>It’s inside the stream event that we make our changes. First, if the file ends with <code>.html</code> we respond with the file matching the name and assign the correct value to the <code>content-type</code> header.  If there’s an error we respond with <code>respondToStreamError</code>.</p>
<p>We could use the same system to generate responses for other content types that we know we’ll serve on our pages.</p>
<pre><code class="language-javascript">  if (fullPath.endsWith(&quot;.html&quot;)) {
      console.log('html');
      // handle HTML file
      stream.respondWithFile(fullPath, {
        &quot;content-type&quot;: &quot;text/html&quot;
      }, {
        onError: (err) =&gt; {
          respondToStreamError(err, stream);
        }
      });
</code></pre>
<p>We use <code>pushStream</code> to initate a push event. We know that we want to push <code>font.woff</code> and we know the id of the parent stream. All that is lleft is to add the resource to the push stream send it to the client.</p>
<p>As usual, if we get an error we use <code>respondToStreamError</code> to provide a response.</p>
<pre><code class="language-javascript">      stream.pushStream({ &quot;:path&quot;: &quot;/font.woff&quot; }, { parent: stream.id }, (pushStream) =&gt; {
        console.log('pushing');
        pushStream.respondWithFile(path.join(serverRoot, &quot;/font.woff&quot;), {
          'content-type': &quot;text/css&quot;
        }, {
            onError: (err) =&gt; {
              respondToStreamError(err, pushStream);
            }
        });
      });
</code></pre>
<p>If it’s not an HTML file then we just serve it normally, using <code>respondWithFile</code> to return the resource and using <code>responseMimeType</code> as the value for the <code>content-type</code> header.</p>
<pre><code class="language-javascript">  } else {
    // handle static file
    console.log(fullPath);
    stream.respondWithFile(fullPath, {
      'content-type': responseMimeType
    }, {
      onError: (err) =&gt; respondToStreamError(err, stream)
    });
  }

});
</code></pre>
<p>The last step is to hear for requests on the specified port.</p>
<pre><code class="language-javascript">server.listen(7350);
</code></pre>
<h2>Express</h2>
<p>Express has plans to support the native Node.js  implementation on version 5.0, which is currently in alpha release and without support for . If you’re interested there is a <a href="https://github.com/expressjs/express/pull/2237">tracking issue</a> for Express 5.0 in Github.</p>
<h2>If you can’t wait</h2>
<p>If you really think you must implement HTTP/2 in your production application right now there are implementations of HTTP/2 and SPDY (the framework that HTTP/2 is based on) available.</p>
<p>I’ve played with the <a href="https://github.com/spdy-http2/node-spdy">node-spdy</a> module. It provides a more mature implementation of HTTP/2 in Node and also supports the Google propietary SPDY server extensions that were the basis for HTTP/2.</p>
<p>After installing the <code>spdy</code> module (<code>npm i spdy</code>) my starting point (taken from the module’s <a href="https://github.com/spdy-http2/node-spdy/blob/master/README.md">README</a>) looks like this</p>
<pre><code class="language-javascript">const spdy = require('spdy');
const fs = require('fs');

const options = {
  key: fs.readFileSync('./key.pem'),
  cert: fs.readFileSync('./cert.pem'),

  spdy: {
    protocols: ['h2', 'spdy/3.1', 'http/1.1'],
    plain: false,
    'x-forwarded-for': false,

    connection: {
      windowSize: 1024 * 1024, // Server's window size
      autoSpdy31: false
    }
  }
};

const server = spdy.createServer(options, function (req, res) {
  res.writeHead(200);
  res.end('hello world!');
});

server.listen(3000);
</code></pre>
<h2>Links and Resources</h2>
<ul>
<li>HTTP/2 Specs
<ul>
<li>Hypertext Transfer Protocol version 2 - <a href="https://httpwg.github.io/specs/rfc7540.html">RFC7540</a></li>
<li>HPACK - Header Compression for HTTP/2 - <a href="https://httpwg.github.io/specs/rfc7541.html">RFC7541</a></li>
</ul>
</li>
<li><a href="https://http2.github.io/faq/">HTTP/2 FAQ</a></li>
<li><a href="https://developers.google.com/web/fundamentals/performance//">Introduction to HTTP/2</a></li>
<li><a href="https://docs.google.com/document/d/1K0NykTXBbbbTlv60t5MyJvXjqKGsCVNYHyLEXIxYMv0/edit">Rules of Thumb for HTTP/2 Push</a></li>
<li><a href="https://nodejs.org/api/http2.html">Node.js HTTP/2 documentation</a></li>
<li><a href="https://github.com/spdy-http2/node-spdy">node-spdy module</a></li>
</ul>
