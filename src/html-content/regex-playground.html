<h1 id="regular-expressions-and-string-manipulation-playground">Regular Expressions and String Manipulation Playground</h1>
<p>Sooner or later every programmer will use <a href="https://en.wikipedia.org/wiki/Regular_expression">Regular Expressions</a> in their code. To me they are hard to understand and reason... this post will try to clear up some of my confusion and provide examples of what these regular expressions look like.</p>
<h2 id="writing-regular-expressions">Writing regular expressions</h2>
<p>The first step is writing regular expressions. We have two ways of doing it: literals and constructors.</p>
<h3 id="regular-expression-literals">Regular expression literals</h3>
<p>The simplest way to write regular expressions is to use them as a literal value in a constant or variable, the pattern is enclosed in slashes (<code>/</code>).</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> myRE <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">a+bc</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
</code></pre>
<p>Literal regular expressions are evaluated when the script is loaded. Use RegExp literals when you know what the regular expression will be.</p>
<h3 id="regular-expression-constructors">Regular expression constructors</h3>
<p>We can also build regular expressions using the <code>RegExp</code> constructor where we put the regular expression that we want to test in parenthesis.</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> myRE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token string">'a+bc'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>The constructors are evaluated when the script runs. Use constructors when you're not certain what the expression will be or when you're working with user input.</p>
<h2 id="modifying-the-regular-expression%3A-special-characters-and-creating-patterns">Modifying the regular expression: special characters and creating patterns</h2>
<p>There are times when patterns like those we discussed are enough for our needs but there are times when we need to build more complicated expressions. We may want to match portions of a URL or make sure that the protocol used for the URL is <code>https://</code>.</p>
<p>There are special characters that we can use to enhace the expressions to perform specific tasks.</p>
<p>The table below, taken from MDN's <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Writing_a_regular_expression_pattern">Writing a regular expression pattern</a> shows the characters you can use in regular expressions and what they do.</p>
<p>&lt;table&gt;
&lt;caption&gt;Special characters in regular expressions.&lt;/caption&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope=&quot;col&quot;&gt;Character&lt;/th&gt;
&lt;th scope=&quot;col&quot;&gt;Meaning&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;<code>\</code>&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Matches according to the following rules:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A backslash that precedes a non-special character indicates that the next character is special and is not to be interpreted literally. For example, a '&lt;code&gt;b&lt;/code&gt;' without a preceding '' generally matches lowercase 'b's wherever they occur. But a '&lt;code&gt;\b&lt;/code&gt;' by itself doesn't match any character; it denotes a word boundary.&lt;/li&gt;
&lt;li&gt;A backslash that precedes a special character indicates that the next character is not special and should be interpreted literally. For example, the pattern &lt;code&gt;/a*/&lt;/code&gt; relies on the special character '&lt;code&gt;<em>&lt;/code&gt;' to match 0 or more a's. By contrast, the pattern &lt;code&gt;/a*/&lt;/code&gt; denotes the '&lt;code&gt;</em>&lt;/code&gt;'  as not special, enabling matches with strings like 'a*'.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Do not forget to escape \ itself while using the RegExp(&quot;pattern&quot;) notation because \ is also an escape character in strings.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;^&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Matches beginning of input. If the multiline flag is set to true, also matches immediately after a line break character.&lt;br&gt;
&lt;br&gt;
For example, &lt;code&gt;/^A/&lt;/code&gt; does not match the 'A' in &quot;an A&quot;, but does match the 'A' in &quot;An E&quot;.&lt;br&gt;
&lt;br&gt;
The '&lt;code&gt;^&lt;/code&gt;' has a different meaning when it appears as the first character in a character set pattern.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Matches end of input. If the multiline flag is set to true, also matches immediately before a line break character.&lt;/p&gt;
&lt;p&gt;For example, &lt;code&gt;/t$/&lt;/code&gt; does not match the 't' in &quot;eater&quot;, but does match it in &quot;eat&quot;.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;<em>&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Matches the preceding expression 0 or more times. Equivalent to {0,}.&lt;/p&gt;
&lt;p&gt;For example, &lt;code&gt;/bo</em>/&lt;/code&gt; matches 'boooo' in &quot;A ghost booooed&quot; and 'b' in &quot;A bird warbled&quot; but nothing in &quot;A goat grunted&quot;.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Matches the preceding expression 1 or more times. Equivalent to &lt;code&gt;{1,}&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For example, &lt;code&gt;/a+/&lt;/code&gt; matches the 'a' in &quot;candy&quot; and all the a's in &quot;caaaaaaandy&quot;, but nothing in &quot;cndy&quot;.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;?&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Matches the preceding expression 0 or 1 time. Equivalent to &lt;code&gt;{0,1}&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For example, &lt;code&gt;/e?le?/&lt;/code&gt; matches the 'el' in &quot;angel&quot; and the 'le' in &quot;angle&quot; and also the 'l' in &quot;oslo&quot;.&lt;/p&gt;
&lt;p&gt;If used immediately after any of the quantifiers <em>, +, ?, or {}, makes the quantifier non-greedy (matching the fewest possible characters), as opposed to the default, which is greedy (matching as many characters as possible). For example, applying &lt;code&gt;/\d+/&lt;/code&gt; to &quot;123abc&quot; matches &quot;123&quot;. But applying &lt;code&gt;/\d+?/&lt;/code&gt; to that same string matches only the &quot;1&quot;.&lt;/p&gt;
&lt;p&gt;Also used in lookahead assertions, as described in the &lt;code&gt;x(?=y)&lt;/code&gt; and &lt;code&gt;x(?!y)&lt;/code&gt; entries of this table.&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;.&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;(The decimal point) matches any single character except the newline character, by default.&lt;/p&gt;
&lt;p&gt;For example, &lt;code&gt;/.n/&lt;/code&gt; matches 'an' and 'on' in &quot;nay, an apple is on the tree&quot;, but not 'nay'.&lt;/p&gt;
&lt;p&gt;If the &lt;code&gt;s&lt;/code&gt; (&quot;dotAll&quot;) flag is set to true, it also matches newline characters.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;(x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Matches 'x' and remembers the match, as the following example shows. The parentheses are called &lt;em&gt;capturing parentheses&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The '&lt;code&gt;(foo)&lt;/code&gt;' and '&lt;code&gt;(bar)&lt;/code&gt;' in the pattern &lt;code&gt;/(foo) (bar) \1 \2/&lt;/code&gt; match and remember the first two words in the string &quot;foo bar foo bar&quot;. The &lt;code&gt;\1&lt;/code&gt; and &lt;code&gt;\2&lt;/code&gt;  denote the first and second parenthesized substring matches - &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt;, matching the string's last two words. Note that &lt;code&gt;\1&lt;/code&gt;, &lt;code&gt;\2&lt;/code&gt;, ..., &lt;code&gt;\n&lt;/code&gt; are used in the matching part of the regex. In the replacement part of a regex the syntax &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, ..., &lt;code&gt;$n&lt;/code&gt; must be used, e.g.: &lt;code&gt;'bar foo'.replace(/(...) (...)/, '$2 $1')&lt;/code&gt;.  &lt;code&gt;$&amp;&lt;/code&gt; means the whole matched string.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;(?:x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;Matches 'x' but does not remember the match. The parentheses are called &lt;em&gt;non-capturing parentheses&lt;/em&gt;, and let you define subexpressions for regular expression operators to work with. Consider the sample expression &lt;code&gt;/(?:foo){1,2}/&lt;/code&gt;. If the expression was &lt;code&gt;/foo{1,2}/&lt;/code&gt;, the &lt;code&gt;{1,2}&lt;/code&gt; characters would apply only to the last 'o' in 'foo'. With the non-capturing parentheses, the &lt;code&gt;{1,2}&lt;/code&gt; applies to the entire word 'foo'.&lt;/p&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;x(?=y)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Matches 'x' only if 'x' is followed by 'y'. This is called a lookahead.&lt;/p&gt;
&lt;p&gt;For example, &lt;code&gt;/Jack(?=Sprat)/&lt;/code&gt; matches 'Jack' only if it is followed by 'Sprat'. &lt;code&gt;/Jack(?=Sprat|Frost)/&lt;/code&gt; matches 'Jack' only if it is followed by 'Sprat' or 'Frost'. However, neither 'Sprat' nor 'Frost' is part of the match results.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;x(?!y)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Matches 'x' only if 'x' is not followed by 'y'. This is called a negated lookahead.&lt;/p&gt;
&lt;p&gt;For example, &lt;code&gt;/\d+(?!.)/&lt;/code&gt; matches a number only if it is not followed by a decimal point. The regular expression &lt;code&gt;/\d+(?!.)/.exec(&quot;3.141&quot;)&lt;/code&gt; matches '141' but not '3.141'.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;(?&lt;=&lt;em&gt;y&lt;/em&gt;)&lt;em&gt;x&lt;/em&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Matches &lt;code&gt;&lt;em&gt;x&lt;/em&gt;&lt;/code&gt; only if &lt;code&gt;&lt;em&gt;x&lt;/em&gt;&lt;/code&gt; is preceded by &lt;code&gt;&lt;em&gt;y&lt;/em&gt;&lt;/code&gt;.This is called a lookbehind.&lt;/p&gt;
&lt;p&gt;For example, /&lt;code&gt;(?&lt;=Jack)Sprat/&lt;/code&gt; matches &quot;Sprat&quot; only if it is preceded by &quot;Jack&quot;.&lt;br&gt;
&lt;code&gt;/(?&lt;=Jack|Tom)Sprat/&lt;/code&gt; matches &quot;Sprat&quot; only if it is preceded by &quot;Jack&quot; or &quot;Tom&quot;.&lt;br&gt;
However, neither &quot;Jack&quot; nor &quot;Tom&quot; is part of the match results.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;(?&lt;!&lt;em&gt;y&lt;/em&gt;)&lt;em&gt;x&lt;/em&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Matches &lt;code&gt;&lt;em&gt;x&lt;/em&gt;&lt;/code&gt; only if &lt;code&gt;&lt;em&gt;x&lt;/em&gt;&lt;/code&gt; is not preceded by &lt;code&gt;&lt;em&gt;y&lt;/em&gt;&lt;/code&gt;.This is called a negated lookbehind.&lt;/p&gt;
&lt;p&gt;For example, &lt;code&gt;/(?&lt;!-)\d+/&lt;/code&gt; matches a number only if it is not preceded by a minus sign.&lt;br&gt;
&lt;code&gt;/(?&lt;!-)\d+/.exec('3')&lt;/code&gt; matches &quot;3&quot;.&lt;br&gt;
 &lt;code&gt;/(?&lt;!-)\d+/.exec('-3')&lt;/code&gt;  match is not found because the number is preceded by the minus sign.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;x|y&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Matches 'x', or 'y' (if there is no match for 'x').&lt;/p&gt;
&lt;p&gt;For example, &lt;code&gt;/green|red/&lt;/code&gt; matches 'green' in &quot;green apple&quot; and 'red' in &quot;red apple.&quot; The order of 'x' and 'y' matters. For example &lt;code&gt;a</em>|b&lt;/code&gt; matches the empty string in &quot;b&quot;, but &lt;code&gt;b|a*&lt;/code&gt; matches &quot;b&quot; in the same string.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;{n}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;Matches exactly n occurrences of the preceding expression. N must be a positive integer.&lt;/p&gt;
&lt;p&gt;For example, &lt;code&gt;/a{2}/&lt;/code&gt; doesn't match the 'a' in &quot;candy,&quot; but it does match all of the a's in &quot;caandy,&quot; and the first two a's in &quot;caaandy.&quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;{n,}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Matches at least n occurrences of the preceding expression. N must be a positive integer.&lt;/p&gt;
&lt;p&gt;For example, /a{2,}/ will match &quot;aa&quot;, &quot;aaaa&quot; and &quot;aaaaa&quot; but not &quot;a&quot;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;{n,m}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Where &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;m&lt;/code&gt; are positive integers and &lt;code&gt;n &lt;= m&lt;/code&gt;. Matches at least &lt;code&gt;n&lt;/code&gt; and at most &lt;code&gt;m&lt;/code&gt; occurrences of the preceding expression. When &lt;code&gt;m&lt;/code&gt; is omitted, it's treated as ∞.&lt;/p&gt;
&lt;p&gt;For example, &lt;code&gt;/a{1,3}/&lt;/code&gt; matches nothing in &quot;cndy&quot;, the 'a' in &quot;candy,&quot; the first two a's in &quot;caandy,&quot; and the first three a's in &quot;caaaaaaandy&quot;. Notice that when matching &quot;caaaaaaandy&quot;, the match is &quot;aaa&quot;, even though the original string had more a's in it.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[xyz]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;Character set. This pattern type matches any one of the characters in the brackets, including escape sequences. Special characters like the dot(&lt;code&gt;.&lt;/code&gt;) and asterisk (&lt;code&gt;<em>&lt;/code&gt;) are not special inside a character set, so they don't need to be escaped. You can specify a range of characters by using a hyphen, as the following examples illustrate.&lt;/p&gt;
&lt;p&gt;The pattern&lt;code&gt; [a-d]&lt;/code&gt;, which performs the same match as &lt;code&gt;[abcd]&lt;/code&gt;, matches the 'b' in &quot;brisket&quot; and the 'c' in &quot;city&quot;. The patterns &lt;code&gt;/[a-z.]+/ &lt;/code&gt;and &lt;code&gt;/[\w.]+/&lt;/code&gt; match the entire string &quot;test.i.ng&quot;.&lt;p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[^xyz]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;A negated or complemented character set. That is, it matches anything that is not enclosed in the brackets. You can specify a range of characters by using a hyphen. Everything that works in the normal character set also works here.&lt;/p&gt;
&lt;p&gt;For example, &lt;code&gt;[^abc]&lt;/code&gt; is the same as &lt;code&gt;[^a-c]&lt;/code&gt;. They initially match 'r' in &quot;brisket&quot; and 'h' in &quot;chop.&quot;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[\b]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;Matches a backspace (U+0008). You need to use square brackets if you want to match a literal backspace character. (Not to be confused with &lt;code&gt;\b&lt;/code&gt;.)&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Matches a &lt;em&gt;word boundary&lt;/em&gt;. A word boundary matches the position between a word character followed by a non-word character, or between a non-word character followed by a word character, or the beginning of the string, or the end of the string. A word boundary is not a &quot;character&quot; to be matched; like an anchor, a word boundary is not included in the match. In other words, the length of a matched word boundary is zero. (Not to be confused with &lt;code&gt;[\b]&lt;/code&gt;.)&lt;/p&gt;
&lt;p&gt;Examples using the input string &quot;moon&quot;:&lt;br&gt;
&lt;code&gt;/\bm/&lt;/code&gt; matches, because the <code>\b</code> is at the beginning of the string;&lt;p&gt;
&lt;p&gt;the '\b' in &lt;code&gt;/oo\b/&lt;/code&gt; does not match, because the '\b' is both preceded and followed by word characters;&lt;/p&gt;
&lt;p&gt;the '\b' in &lt;code&gt;/oon\b/&lt;/code&gt; matches, because it appears at the end of the string;&lt;/p&gt;
&lt;p&gt;the '\b\ in &lt;code&gt;/\w\b\w/&lt;/code&gt; will never match anything, because it is both preceded and followed by a word character..&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; JavaScript's regular expression engine defines a &lt;a rel=&quot;noopener&quot; href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-15.10.2.6&quot;&gt;specific set of characters&lt;/a&gt; to be &quot;word&quot; characters. Any character not in that set is considered a non-word character. This set of characters is fairly limited: it consists solely of the Roman alphabet in both upper- and lower-case, decimal digits, and the underscore character. Accented characters, such as &quot;é&quot; or &quot;ü&quot; are, unfortunately, treated as non-word characters for the purposes of word boundaries, as are ideographic characters in general.&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\B&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Matches a non-&lt;em&gt;word boundary&lt;/em&gt;. This matches the following cases:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Before the first character of the string.&lt;/li&gt;
&lt;li&gt;After the last character of the string,.&lt;/li&gt;
&lt;li&gt;Between two word characters&lt;/li&gt;
&lt;li&gt;Between two non-word characters&lt;/li&gt;
&lt;li&gt;The empty string&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For example, &lt;code&gt;/\B../&lt;/code&gt; matches 'oo' in &quot;noonday&quot;, and &lt;code&gt;/y\B./&lt;/code&gt; matches 'ye' in &quot;possibly yesterday.&quot;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\c&lt;em&gt;X&lt;/em&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Where &lt;em&gt;X&lt;/em&gt; is a character ranging from A to Z. Matches a control character in a string.&lt;/p&gt;
&lt;p&gt;For example, &lt;code&gt;/\cM/&lt;/code&gt; matches control-M (U+000D) in a string.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\d&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Matches a digit character. Equivalent to &lt;code&gt;[0-9]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For example, &lt;code&gt;/\d/&lt;/code&gt; or &lt;code&gt;/[0-9]/&lt;/code&gt; matches '2' in &quot;B2 is the suite number.&quot;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\D&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Matches a non-digit character. Equivalent to &lt;code&gt;[^0-9]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For example, &lt;code&gt;/\D/&lt;/code&gt; or &lt;code&gt;/[^0-9]/&lt;/code&gt; matches 'B' in &quot;B2 is the suite number.&quot;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\f&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Matches a form feed (U+000C).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\n&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Matches a line feed (U+000A).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\r&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Matches a carriage return (U+000D).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Matches a white space character, including space, tab, form feed, line feed. Equivalent to &lt;code&gt;[ \f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For example, &lt;code&gt;/\s\w</em>/&lt;/code&gt; matches ' bar' in &quot;foo bar.&quot;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\S&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Matches a character other than white space. Equivalent to &lt;code&gt;[^ \f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For example, &lt;code&gt;/\S*/&lt;/code&gt; matches 'foo' in &quot;foo bar.&quot;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Matches a tab (U+0009).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\v&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Matches a vertical tab (U+000B).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\w&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Matches any alphanumeric character including the underscore. Equivalent to &lt;code&gt;[A-Za-z0-9_]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For example, &lt;code&gt;/\w/&lt;/code&gt; matches 'a' in &quot;apple,&quot; '5' in &quot;$5.28,&quot; and '3' in &quot;3D.&quot;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\W&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Matches any non-word character. Equivalent to &lt;code&gt;[^A-Za-z0-9_]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For example, &lt;code&gt;/\W/&lt;/code&gt; or &lt;code&gt;/[^A-Za-z0-9_]/&lt;/code&gt; matches '%' in &quot;50%.&quot;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;em&gt;n&lt;/em&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Where &lt;em&gt;n&lt;/em&gt; is a positive integer, a back reference to the last substring matching the &lt;em&gt;n&lt;/em&gt; parenthetical in the regular expression (counting left parentheses).&lt;/p&gt;
&lt;p&gt;For example, &lt;code&gt;/apple(,)\sorange\1/&lt;/code&gt; matches 'apple, orange,' in &quot;apple, orange, cherry, peach.&quot;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\0&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Matches a NULL (U+0000) character. Do not follow this with another digit, because &lt;code&gt;\0&lt;digits&gt;&lt;/code&gt; is an octal (base 8) sequence. Instead use &lt;code&gt;\x00&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\xhh&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Matches the character with the code hh (two hexadecimal digits)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</p>
<p>Goingh back to finding a regular expression that tests if our URL is to a secure site we can do the following:</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> secureURL <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">https:\/\/</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
</code></pre>
<p>We'll use the regular expression when we look at how to test using regular expressions in the next section.</p>
<h2 id="additional-flags-for-regular-expressions">Additional flags for regular expressions</h2>
<p>One last set of flags to worry about. These are additional parameters for the expression that will allow additional flexibility beyond what special characters allow.</p>
<p>The table below show what these additional flags are and what they do.</p>
<p>&lt;table&gt;
&lt;caption&gt;Regular expression flags&lt;/caption&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope=&quot;col&quot;&gt;Flag&lt;/th&gt;
&lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Global search.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;i&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Case-insensitive search.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;m&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Multi-line search.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Allows &lt;code&gt;.&lt;/code&gt; to match newline characters.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;u&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&quot;Treat a pattern as a sequence of unicode code points&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;y&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Perform a &quot;sticky&quot; search that matches starting at the current position in the target string.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</p>
<p>The flags are appended to the end of the regular expression and are a part of it (no adding or removing flags after the regular expression) and they will change the way we build the regular expressions we want to use.</p>
<p>The literal expression now looks like this:</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> re <span class="token operator">=</span> <span class="token operator">/</span>pattern<span class="token operator">/</span>flags<span class="token punctuation">;</span>
</code></pre>
<p>And the constructor changes to the one below</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> re <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token string">'pattern'</span><span class="token punctuation">,</span> <span class="token string">'flags'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="matching-text-against-regular-expressions">Matching text against regular expressions</h2>
<p>We have multiple ways to test strings against our regular expressions. Which one to use depends on what results you want to accomplish and how much information about the matches and the results you want to keep and use.</p>
<p>The methods are listed below:</p>
<p>&lt;table&gt;
&lt;caption&gt;Methods that use regular expressions&lt;/caption&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope=&quot;col&quot;&gt;Method&lt;/th&gt;
&lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;exec&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;A &lt;code&gt;RegExp&lt;/code&gt; method that executes a search for a match in a string. It returns an array of information or null on a mismatch.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;test&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;A &lt;code&gt;RegExp&lt;/code&gt; method that tests for a match in a string. It returns true or false.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;match&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;A &lt;code&gt;String&lt;/code&gt; method that executes a search for a match in a string. It returns an array of information or null on a mismatch.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;matchAll&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;A &lt;code&gt;String&lt;/code&gt; method that returns an iterator containing all of the matches, including capturing groups.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;search&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;A &lt;code&gt;String&lt;/code&gt; method that tests for a match in a string. It returns the index of the match, or -1 if the search fails.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;replace&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;A &lt;code&gt;String&lt;/code&gt; method that executes a search for a match in a string, and replaces the matched substring with a replacement substring.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;split&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;A &lt;code&gt;String&lt;/code&gt; method that uses a regular expression or a fixed string to break a string into an array of substrings.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</p>
<h3 id="what-happens-when-the-string-has-unicode-characters%3F">What happens when the string has Unicode Characters?</h3>
<p>&lt;table&gt;
&lt;caption&gt;Unicode special characters for regular expressions.&lt;/caption&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope=&quot;col&quot;&gt;Character&lt;/th&gt;
&lt;th scope=&quot;col&quot;&gt;Meaning&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\uhhhh&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Matches the character with the code hhhh (four hexadecimal digits).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\u{hhhh}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;(only when u flag is set) Matches the character with the Unicode value hhhh (hexadecimal digits).&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</p>
<h3 id="making-life-easier%3A-groups">Making life easier: groups</h3>
<h2 id="matching-multiple-items-in-the-string">Matching multiple items in the string</h2>
<p><a href="https://v8.dev/blog/v8-release-73#string.prototype.matchall">String.prototype.matchAll</a></p>
<p>A common use case of global (g) or sticky (y) regular expressions is applying it to a string and iterating through all of the matches. The new String.prototype.matchAll API makes this easier than ever before, especially for regular expressions with capture groups:</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> string <span class="token operator">=</span> <span class="token string">'Favorite GitHub repos: tc39/ecma262 v8/v8.dev'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> regex <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\b(?&lt;owner>[a-z0-9]+)\/(?&lt;repo>[a-z0-9\.]+)\b</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> match <span class="token keyword">of</span> string<span class="token punctuation">.</span><span class="token function">matchAll</span><span class="token punctuation">(</span>regex<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>match<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> at </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>match<span class="token punctuation">.</span>index<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> with '</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>match<span class="token punctuation">.</span>input<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">'</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">→ owner: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>match<span class="token punctuation">.</span>groups<span class="token punctuation">.</span>owner<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">→ repo: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>match<span class="token punctuation">.</span>groups<span class="token punctuation">.</span>repo<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Output:</span>
<span class="token comment">//</span>
<span class="token comment">// tc39/ecma262 at 23 with 'Favorite GitHub repos: tc39/ecma262 v8/v8.dev'</span>
<span class="token comment">// → owner: tc39</span>
<span class="token comment">// → repo: ecma262</span>
<span class="token comment">// v8/v8.dev at 36 with 'Favorite GitHub repos: tc39/ecma262 v8/v8.dev'</span>
<span class="token comment">// → owner: v8</span>
<span class="token comment">// → repo: v8.dev</span>
</code></pre>
<h2 id="links%2C-resources-and-ideas-for-further-experimentation">Links, resources and Ideas for further experimentation</h2>
<ul>
<li>https://alligator.io/js/regular-expressions-for-regular-people/</li>
<li>https://www.smashingmagazine.com/2019/02/regexp-features-regular-expressions/</li>
</ul>
