<html lang="en">

<head>
  <!-- <link rel="stylesheet" href="../paged-media/highlight/styles/solarized-light.css"> -->
  <link rel="stylesheet" href="../paged-media/prism/prism.css">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,minimum-scale=1,maximum-scale=1">
  <title></title>
</head>

<body data-type="book">

  <h1>Using ES modules in Node</h1>
<p>Node has had experimental support for <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules">EcmaScript modules</a> for a while.</p>
<p>Again, this is one thing I’ve wanted to explore for a while but have never felt the need to dig deeply. After all, it is experimental and it hasn’t been approved for production use.</p>
<p>But wit the release of Node 14 we’re coming to the point when module support moved to stable.</p>
<p>So let’s explore what it takes to run ES Modules in Node on their own and together with current Node modules.</p>
<h2>What will Node consider an ES Module?</h2>
<p>There are certain file extensions and conditions that will cause Node to treat files as ES Modules. These conditions/extensions include:</p>
<ul>
<li>Files ending in <code>.mjs</code></li>
<li>Files ending in <code>.js</code> when the nearest parent <code>package.json</code> file contains a top-level field <code>&quot;type&quot;: &quot;module&quot;</code></li>
<li>Files ending in <code>.js</code> when Node runs with the <code>--experimental-modules</code> flag (versions of Node before 14.x)</li>
<li>Strings passed in as an argument to <code>--eval</code> or <code>--print</code>, or piped to <code>node</code> via <code>STDIN</code>, with the flag <code>--input-type=module</code></li>
</ul>
<p>So, in theory, we could use <code>.mjs</code> for all our ES Modules files but we need to be careful as your server needs to be confiured to serve <code>.mjs</code> files as Javascript and I’m not certain all servers are confiured to do this out of the box.</p>
<h2>File extensions</h2>
<p>Two extensions have special meaning. As we discussed earlier in this post, <code>.mjs</code> will always be treated as an ES Module file</p>
<pre><code class="language-js">import 'commonjs-package/src/index.mjs';
// Loaded as ES module since .mjs is always
// loaded as ES module.
</code></pre>
<p>The <code>.cjs</code> extension is the opposite. This file will always load as a Common JS module.</p>
<pre><code class="language-js">import './legacy-file.cjs';
// Loaded as CommonJS since .cjs is always
// loaded as CommonJS.
</code></pre>
<h2>Running Node with module support</h2>
<p>As of Node 12.16.3, the latest LTS Node version as of this writing, the command to run Node with experimental Node Module support is:</p>
<pre><code class="language-bash">node --experimental-modules colors.js
</code></pre>
<p>Using this flag we’ll be able to run the same code both on Node and on the browser.</p>
<p>If you’re interested, keep an eye for anouncements about modules in Node. This may change in unpexpected ways so check the <a href="https://nodejs.org/api/esm.html">documentation</a> and be ready.</p>
<h2>Links and Resources</h2>
<ul>
<li><a href="https://blog.logrocket.com/how-to-use-ecmascript-modules-with-node-js/">How to use ECMAScript modules with Node.js</a> (LogRocket)</li>
<li><a href="https://v8.dev/features/modules">JavaScript modules</a> (V8)</li>
<li><a href="https://2ality.com/2019/04/nodejs-esm-impl.html">The new ECMAScript module support in Node.js 12</a></li>
<li><a href="https://nodejs.org/api/esm.html">Node.js v12.16.3 Documentation</a> for ES Modules</li>
</ul>


<!-- <script src="../paged-media/highlight/highlight.pack.js"></script> -->
<script src="../paged-media/prism/prism.js"></script>
</body>
</html>