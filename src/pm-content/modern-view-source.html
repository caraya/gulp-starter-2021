<html lang="en">

<head>
  <!-- <link rel="stylesheet" href="../paged-media/highlight/styles/solarized-light.css"> -->
  <link rel="stylesheet" href="../paged-media/prism/prism.css">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,minimum-scale=1,maximum-scale=1">
  <title></title>
</head>

<body data-type="book">

  <h1 id="what-is-the-modern-view-source%3F">What is the modern view-source?</h1>
<p>I started working on the web in 1994 and I’ve been privy to the evolution and complication of the web and its component technologies.</p>
<p>The web was much simpler then, with a limited set of tags and little CSS and JavaScript that only changed the look of items on the page. If we wanted applications we had the option of Perl or C to create CGI script and roundtrips to the server for each request.</p>
<p>We’ve improved considerably from those days to where the web is now. We have hundreds, if not thousands, of projects that we can learn from but that’s not the answer. While we have many more projects to learn from the process itself has become way more complicated. It’s not just the code itself but also how it’s processed and bundled. It’s also what tools do we use and how they work together and how changing from one tool to another will force us to rewrite pieces of the code.</p>
<p>Frank Chimero’s <a href="https://frankchimero.com/writing/everything-easy-is-hard-again/">Everything Easy is Hard Again</a> presents the view of someone who left the web design business and returned a few years later to find out how much more complex the we had become and how much more we do for the sake of doing it.</p>
<div class="video">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/koS4vjSux8A" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
<p>It’s from this viewpoint that messages like this worry me.</p>
<blockquote>
  <p>“Can we agree that, in 2018, human-readable “View Source” is a constraint the web can discard? I benefitted from “View Source” too, but today we have an embarrassment of resources and open source examples I would have killed for as a kid.”&mdash; <a href="https://twitter.com/tomdale/status/965681976199077889">Tom Dale</a></p>
</blockquote>
<p><a href="https://snook.ca/archives/opinion/view-source">Jonathan Snook</a> and <a href="https://christianheilmann.com/2018/07/09/different-views-on-view-source/">Christian Heilmann</a> present two interesting positions on the issue of having text-based renditions of our content in addition to what’s interpreted by the browser to provide the output on-screen.</p>
<p>Snook writes towards the end of his post:</p>
<p><strong>The sites some build may be simple static sites, befitting of a simple View Source. The sites some build may be compiled and bundled and requiring tools that allow us to dig deeper. Just because you don’t need those tools doesn’t mean that somebody doesn’t need those tools.</strong></p>
<p>Chris Heilmann makes three points that I think are interesting to look at:</p>
<p><strong>Except for a few purist web sites out there, what you see in your current device isn’t the code of the web site.</strong></p>
<p>The bytes sent to the browser may be different because the browser decided what image to load or the JS engine decided what script to load when using modules and providing fallback for older browsers. Even if the loading process injected JavaScript, styles, or images into the page the source of the document will still match what’s rendered.</p>
<p><strong>Code sent to the web is often minimised and bundled. Developer tools give you options to pretty-print those and thus make them much more understandable.</strong></p>
<p>DevTools in all modern browsers work hard in letting you see what the code you’re viewing really look like and give you a human-readable version of the code, within the limitations of the tool themselves:</p>
<ul>
<li>Minimized JavaScript expanded by Chrome DevTools is still nearly impossible to read when the tool also mangles variable names to single characters</li>
<li>Looking at the code generated by Webpack you get more lines of Webpack code than bundled code and, in multi bundle situations, it becomes harder to extract the code that we want to inspect</li>
</ul>
<p><strong>Of course it is great that there is no barrier to entry if you want to know how something works. But the forgiving nature of HTML and CSS can also lead to problems.</strong></p>
<p>I agree that HTML can cause problems but it’s on us as developers, as standards organizations and as people who teach about the web that it got to where it is. Some developers embraced the tag soup markup (a defensive measure to make sure that the web still worked in modern browsers) and produced markup that would never validate as HTML in any strict validator… and we claimed it was OK and we moved on. As a result web browsers must be forgiving because developers took the shortest path to a result rather than taking the correct path to the solution.</p>
<p>We need to put the best examples front and center so that people who copy and paste code will find semantic correct HTML rather than tag soup garbage.</p>
<p>But there are more fundamental questions than whether we should have view source for our web content or whether view source is a constraint to current web development.</p>
<h2 id="the-entry-barrier">The entry barrier</h2>
<p>What do we need to learn in order to do basic web development? What APIs and what technologies? It’s not enough to know HTML, CSS and JavaScript but you have to make selections about build systems (either your own choice or whatever your project is using), what version of JavaScript will you use, whether you want to use templates for your project and, if so, whether to use native templates or a templating engine. The choices keep increasing and get more complicated with new technologies and frameworks being released frequently.</p>
<p>Pointing people to Github as a resource means that they know what they are looking for and that they are proficient at the target language, Javascript in this case, to recognize the code and what it does.  This wasn’t always the case for me and still isn’t when a beginner looks at code. When I looked at a page it took me a while to figure out what the code did and, several times, I had to copy the code into a page of my own and then play with it until I figured it out or did what I wanted it to do.</p>
<p>But now with all the minimization and bundling of our code it has become very hard, if not outright impossible, to do any kind of “learn by doing” because there is no easy way to identify mangled variables or figure out how many Webpack generated bundles we need to keep to make sure that the code works.</p>
<p>Another of Tom’s quotes in the same Twitter thread makes me wonder if I’m missing something. The tweet in question:</p>
<blockquote>
  <p>I&#39;ll go a step further: insistence on human-readable formats on the web is a pretty intense display of Western privilege. Binary formats are important for reaching people with slower devices and capped data plans. I&#39;ll happily sacrifice my own nostalgia to achieve that goal. &mdash; <a href="https://twitter.com/tomdale/status/966045543112871937">Tom Dale</a></p>
  </blockquote>
<p>I don’t think that a binary format will change the way we address transfer and weight of our web content, if nothing else, we’ll be throwing the same volume of material in a binary format, thus removing any advantage that the binary format offers.</p>
<p>It’s not just the network time that’ll kill your app’s startup performance, but the time spent parsing and evaluating your script, during which time the browser becomes completely unresponsive.</p>
<p>On mobile, there are additional startups that need to happen (cell modem startup and connection, the communication between the cell tower and the Internet, potentially powering up the high-end CPUs to do the heavy lifting on parsing your JavaScript) those milliseconds rack up very quickly</p>
<p>See this presentation from Alex Rusell to get a better understanding of the cllanges of the mobile web. It’s from 2016 but the underlying principles have not changed.</p>
<div class="video">
<iframe width="560" height="315" src="https://www.youtube.com/embed/4bZvq3nodf4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
<p>The following figures show how much stuff measured by median number of requests and size in kilobytes have grown in a 3-year period from 2016 to March, 2019 (data taken from the HTTP Archive’s <a href="https://httparchive.org/reports/state-of-the-web">state of the web</a> report).</p>
<figure>
  <img src='http://publishing-project.rivendellweb.net/wp-content/uploads/2019/04/3-year-requests.png' alt='Timeseries of median total requests over a 3 year period'>
  <figcaption>Timeseries of median total requests over a 3 year period</figcaption>
</figure>
<figure>
  <img src='http://publishing-project.rivendellweb.net/wp-content/uploads/2019/04/3-year-total-kilobytes.png' alt='Timeseries of median total kilobytes over a 3 year period'>
  <figcaption>Timeseries of total kilobytes over a 3 year period</figcaption>
</figure>
<p>I think that to solve the performance problem we’ve created, we have to become more restrictive of what we can and cannot do on the web.  We can start with enforcing best practices for any one of the many performance patterns available… <a href="https://developers.google.com/web/fundamentals/performance/rail">RAIL</a> and <a href="https://developers.google.com/web/fundamentals/performance/prpl-pattern/">PRPL</a> offer actionable goals for you to pursue but actualy meeting the performance goals is up to you.</p>
<p>This is also about being serious in creating a performance culture in our organizations. <a href="https://medium.com/@addyosmani/start-performance-budgeting-dabde04cf6a3">Addy Osmani</a> and <a href="http://designingforperformance.com/weighing-aesthetics-and-performance/#approach-new-designs-with-a-performance-budget">Lara Hogan</a> provide good introductions to performance budgeting.</p>
<p>Tools like <a href="http://www.performancebudget.io/">Performance Budget Calculator</a><a href="https://codepen.io/bradfrost/full/EPQVBp/">Performance Budget Builder</a> and <a href="https://browserdiet.com/calories/">Browser Calories</a> can help in building the budget once we figure out what a budget is and decide that we want to use one for our project.</p>
<p>Smashing magazine publishes an anual front-end performance checklist. <a href="https://www.smashingmagazine.com/2019/01/front-end-performance-checklist-2019-pdf-pages/">The 2019 edition</a> provides .</p>
<p>Once we have the budget we need to enforce it. Webpack has a plugin that will warn (or error out) if you go over a pre-defined bundle size and Pinterest has created an ESLint rule that disallows importing from certain packages.</p>
<p>How we address these performance requirements and how seriously we enforce them is up to us. But I see no other way to really to get out of this bloated mess we’ve turned our web applications into.</p>


<!-- <script src="../paged-media/highlight/highlight.pack.js"></script> -->
<script src="../paged-media/prism/prism.js"></script>
</body>
</html>