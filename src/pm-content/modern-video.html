<html lang="en">

<head>
  <!-- <link rel="stylesheet" href="../paged-media/highlight/styles/solarized-light.css"> -->
  <link rel="stylesheet" href="../paged-media/prism/prism.css">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,minimum-scale=1,maximum-scale=1">
  <title></title>
</head>

<body data-type="book">

  <p><h2 id="introduction">Introduction</h2></p>
<p>When HTML first introduced the <code>video</code> tag I was pumping my fist in joy. No more plugins to play video content. It was as simple as creating marlup like the one below to play and video in an MP4/ACC container with English and Swedish subtitles that can be changed as needed.</p>
<pre><code class="language-html">&lt;!-- Video with subtitles --&gt;
&lt;video src=&quot;foo.mp4&quot; poster=&quot;foo-poster.png&quot;
       width=&quot;640&quot; height=&quot;480&quot; controls&gt;
  &lt;track kind=&quot;subtitles&quot; src=&quot;foo.en.vtt&quot; srclang=&quot;en&quot; label=&quot;English&quot;&gt;
  &lt;track kind=&quot;subtitles&quot; src=&quot;foo.sv.vtt&quot; srclang=&quot;sv&quot; label=&quot;Svenska&quot;&gt;
&lt;/video&gt;

</code></pre>
<p>But it wass never as simple as it looked. Because there was no standard video format for HTML5 video, different browsers supported different container formats and different audio and video codecs. So the video turned into something like this:</p>
<pre><code class="language-html">&lt;video height=&quot;480&quot; width=&quot;640&quot; controls
  poster=&quot;https://archive.org/download/WebmVp8Vorbis/webmvp8.gif&quot; &gt;
  &lt;source
    src=&quot;https://archive.org/download/WebmVp8Vorbis/webmvp8.webm&quot;
    type=&quot;video/webm&quot;&gt;
  &lt;source
    src=&quot;https://archive.org/download/WebmVp8Vorbis/webmvp8_512kb.mp4&quot;
    type=&quot;video/mp4&quot;&gt;
  &lt;source
    src=&quot;https://archive.org/download/WebmVp8Vorbis/webmvp8.ogv&quot;
    type=&quot;video/ogg&quot;&gt;
  Your browser doesn't support HTML5 video tag.
&lt;/video&gt;
</code></pre>
<p>which produces the following video player:</p>
<p><video height="480" width="640" controls
  poster="https://archive.org/download/WebmVp8Vorbis/webmvp8.gif" ></p>
  <source
    src="https://archive.org/download/WebmVp8Vorbis/webmvp8.webm"
    type="video/webm">
  <source
    src="https://archive.org/download/WebmVp8Vorbis/webmvp8_512kb.mp4"
    type="video/mp4">
  <source
    src="https://archive.org/download/WebmVp8Vorbis/webmvp8.ogv"
    type="video/ogg">
  Your browser doesn't support HTML5 video tag.
</video>
<p>Each <code>source</code> element loads a different version of the video encoded with a different set of audio and video codecs. These files must be encoded separately and hosted separately.</p>
<p>There are also patent issues around MP4/h264 and ACC codecs. The <a href="http://www.mpegla.com/main/default.aspx">MPEG Licensing Authority</a> create a <a href="http://www.wipo.int/export/sites/www/ip-competition/en/studies/patent_pools_report.pdf">“patent pool”</a> of essential technologies for MP4 encoding and decoding.</p>
<p>I had hoped that the new HEVC/h265 technology would not be encumbered by MPEG-LA style patent trolls but it was too much, apparently, as MPEG-LA already has an <a href="http://www.mpegla.com/main/programs/HEVC/Pages/Intro.aspx">HVEC patent pool</a></p>
<p>So the fight has remained a stalemate with Mozilla and Opera on one side who refuse to pay the MP4 licensing fee and Microsoft, Google and Apple who have caved in and support MPEG4 playback as part of their HTML5 video implementations.</p>
<p>So, if it’s not MPEG4 or HVEC/h265 then what alternatives do we have available?</p>
<p>While Google implements MPEG4 in Chrome it has not remained static in the video codec front. In 2009 Google <a href="http://www.zdnet.com/article/a-look-at-on2-technologies-and-why-google-wants-it/">purchased On2 Technologies</a> and have worked hard to make VP8, VP9 and its successor, <a href="https://www.webmproject.org/">WebM</a></p>
<p>MPEG-LA must have seen the benefit of VP8 becausse they began forming a patent pool for the technology. Google didn’t like that and the conflict ended with <a href="http://www.osnews.com/story/26849/v">an agreement</a> that would remove the MPEG-LA as a factor in VP8 licensing so that Google can continue to offer the code free and unencumbered for personal and commercial use, for now.</p>
<p>Why is this important?</p>
<blockquote>
<p>Because this means that VP8 is a hell of lot safer and more free from possible legal repercussions than H.264 itself. What many H.264 proponents do not understand, either wilfully or out of sheer ignorance, is that those H.264 licenses embedded in Windows, OS X, iOS, your ‘professional’ camera, and so on, <a href="http://www.osnews.com/story/23236/Why_Our_Civilization_s_Video_Art_and_Culture_is_Threatened_by_the_MPEG-LA">do not cover commercial use</a>. If you shoot a video with your camera in H.264, upload it to YouTube, and get some income from advertisements, you’re in violation of the H.264 license (and the MPEG-LA made it clear they had <a href="http://www.osnews.com/story/22812/MPEG-LA_Further_Solidifies_Theora_as_the_Only_Video_Tag_Choice">no qualms about going after individual users</a>). The extension the MPEG-LA announced (under pressure from VP8 and WebM) changed nothing about that serious legal limitation.</p>
<p>— <a href="http://www.osnews.com/story/26849/v">Google called the MPEG-LA’s bluff, and won</a></p>
</blockquote>
<p><a href="http://www.osnews.com/story/23236/Why_Our_Civilization_s_Video_Art_and_Culture_is_Threatened_by_the_MPEG-LA">Why Our Civilization’s Video Art and Culture is Threatened by the MPEG-LA</a></p>
<p>The other codec worth looking at (mostly because it’s supported by Firefox) is <a href="https://www.theora.org/">OGG Theora</a> from the <a href="http://Xiph.org">Xiph.org</a> Foundation. Like VP8 and WebM Theora is free and unencumbered by patents.</p>
<p>MP4 containers can be optimized for a kind of pseudo streaming by re-arranging the “atoms” of the movie (atoms, in this context, are the chunks of data that make up the movie). The video player is looking or the <code>moov</code> atom and will not play the movie until it finds it.</p>
<p>If your server is configured for <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests">HTTP Range Requests</a> it will request smaller chunks until it find the atom it needs.</p>
<figure>
<img src="http://rigor.com/wp-content/uploads/2016/01/mp4-fast-start.png" alt="">
<figcaption>Different requests for the same video</figcaption>
</figure>
<p>Unfortunately for on-demand movies the <code>moov</code> atom is at the end of the file. So if the server is not configured to handle range requests then the player will have to download the complete file before it can start playing it.</p>
<p>If you’re using already made content or don’t want to re-encode the video you can use tools like <a href="https://handbrake.fr/">Handbrake</a> to optimize the video file for streaming across the web by moving the <code>moov</code> atom to the beginning of the file.</p>
<figure>
<img src="http://rigor.com/wp-content/uploads/2016/01/handbrake.png" alt="">
<figcaption>Using Handbrake to re-arrange the video atoms</figcaption>
</figure>
<p>If you’re working with multiple files or are more comfortable you can use <a href="https://ffmpeg.org/">ffmpeg</a> to encode the file or add the appropriate flag to fast start playback. In the example below we add the <code>faststart</code> flag and use the same audio and video codecs as t he original file.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -movflags faststart \
-acodec copy \
-vcodec copy \
output.mp4
</code></pre>
<p>You can do something similar with WebM videos. The format is based around the <a href="https://matroska.org/">Matroska container</a>, either VP8 or VP9 video codecs and either Opus or Vorbis audio codecs.  Matroska files, usually just called MKV files, use a kind of binary XML called <a href="https://www.wikiwand.com/en/Extensible_Binary_Meta_Language">EBML</a> to store different things like video tracks, audio tracks, subtitles, and other data. These data chunks are called elements and they are similar in concept to the atoms in an MP4 file.</p>
<p>As with all video formats to start playing a WebM video, a browser has to know where the audio and video data is stored in elements. The element we’re looking for is <code>SeekHead</code>.  By default most video creation tools put a SeekHead element at the start of the video. The problem is that each video can have an unlimited number of <code>SeakHead</code>. In this case, the first SeekHead will container a pointer to a second SeekHead located at the end of the file.</p>
<p>Even if the first SeekHead contains pointers to the video and audio tracks, the browser still must go fetch the second SeekHead element, to see if there are additional video or audio tracks in the file, and determine which one has preference. Even if the second SeekHead is completely empty the browser must download and parse all SeekHead elements in the WebM file before it can play video content.</p>
<p>When playing a WebM video locally we don’t need to worry about the file structure since we have all the content available for playback. When streaming a video over HTTP the order of elements does matter because the browser doesn’t have the complete file yet. If the browser doesn’t get certain elements at the beginning of the file it has to send range HTTP requests until it finds the data it needs. This can have impact on how quickly the file starts playing and overall page performance. The discussion below is all about rearranging the elements in the container.</p>
<p>Another aspect of WebM streaming performance is to optimize for seeking inside a video. This is another element, <code>Cues</code>. For the same reasons we are optimizing for fast start we want the <code>Cues</code> element downloaded as early as possible so that, if a user fast forwards the video, they will get a few HTTP downloads as possible.</p>
<p>To accomplish both goals, fast playback and fast seeking we’ll use a single tool, <a href="https://www.matroska.org/downloads/mkclean.html">mkclean</a>, a tool specifically designed to address both the fast start and the fast seek problems. Using <code>original.webm</code> we run the following command to create the resulting <code>optimized.web</code> ready for the web</p>
<pre><code class="language-bash">mkclean --doctype 4 \
--keep-cues \
--optimize \
original.webm optimized.webm
</code></pre>
<p><h3 id="dash-hls">DASH and HLS</h3></p>
<div class="message warning">
  <p>Although DASH is designed for both on-demand and live streaming events, I'll concentrate on on-demand content.</p>
  <p>Also important to note. Even though EME is part of DASH we will not work with EME extensions as I don't believe they should be part of the web platform.</p>
</div>
<p>Because our ecosystem for playing video on the web has changed considerably and now smaller devices (phone, tablets) access our content over unreliable networks subject the way we deliver video has changed.  We need to account for these elements in how we deliver our video.</p>
<p>We’ll work with two specs for streaming video for web delivery are DASH (also known as MPEG-DASH) and Apple’s HSL.</p>
<p><a href="https://www.streamingmedia.com/Articles/Editorial/What-Is-MPEG-DASH/What-is-MPEG-DASH-79041.aspx">Dynamic Adaptive Streaming over HTTP (DASH)</a> is an adaptive bit-rate streaming technique delivered from conventional HTTP web servers.</p>
<p>MPEG-DASH breaks the content into a sequence of small HTTP-based file segments, each segment containing a short interval of playback time of content that is potentially many hours in duration, such as a movie or a live broadcase of a sports event.</p>
<p>Another important consideration is your audience. How many different streams will you provide for your audience? Are these videos encoded and packaged properly?</p>
<p>When creating DASH content you can choose what bit rates you make the content available for by providing videos encoded to those bitrates, the packager creates alternative segments encoded at the target bit rates covering the same, short, intervals of play back time.</p>
<p>While the content is being played back by a DASH client (in this case the web browser), the client automatically selects from the alternatives the next segment to download and play back based on current network conditions.  The client selects the segment with the highest bit rate possible that can be downloaded in time for play back without causing stalls or re-buffering events in the playback. Thus, a browser playing back DASH content can seamlessly adapt to changing network conditions, and provide high quality play back with fewer stalls or re-buffering events.</p>
<p>DASH doesn’t resolve the HTML5 codec issue. DASH is codec agnostic which means that it can be implemented in either H.264 or WebM. This means that we’re back at square one in terms of what code we use and that will mean an increase in costs associated with storage and, potentially, bandwidth delivery.</p>
<p>MPEG-LA has a <a href="http://www.mpegla.com/main/pid/MPEG-DASH/default.aspx">DASH Patent Pool</a> and this has definite impact in adoption among open source purists and adopters including Mozilla, according to Chris Blizzard (at Mozilla when the quote was made):</p>
<blockquote>
<p>Mozilla has always been committed to implementing widely adopted royalty-free standards.  If the underlying MPEG standards were royalty free we would implement DASH. However, MPEG DASH is currently built on top of MPEG Transport Streams, which are not royalty free. Therefore, we are unlikely to implement at this time.</p>
<p>— <a href="http://www.streamingmedia.com/Articles/Editorial/What-Is-.../What-is-MPEG-DASH-79041.aspx">What is MPEG DASH?</a> / November 22, 2011</p>
</blockquote>
<p>Taking out Firefox market share (almost 12% of the browser market) doesn’t make much sense to deploy a technology that will make more work for us in the long run. On the other hand, we can look at what happened with the support of  MP4 and the debacle still ongoing with what combination of container/video/audio codec to support the picture looks a little less bleak, but not by much :)</p>
<p>HLS (HTTP Live Streaming) is a technology developed by Apple as part of the OS X/ iOS media stack that works in a similar fashion to DASH but with different requirements, technologies and features.</p>
<p>The same concerns I raised about DASH apply to HLS. There is also the issue of this being a single vendor specification; there an IETF <a href="https://tools.ietf.org/html/draft-pantos-http-live-streaming-20">Informational Internet Draft</a> there hasn’t been any action to ratify the draft as an IETF standard.</p>
<p>For the rest of this post we’ll concentrate on DASH as it’s the one that has the widest level of support and it means that I don’t have to create the packager or the player later on.</p>
<p><h2 id="process">DASH Process</h2></p>
<p>As I understand it the process to create content ready to play in a DASH-enabled web browser is as follows:</p>
<ol>
<li>Encode the video to the target bit rates you want to use</li>
<li>Create the DASH manifest using the Shaka Packager</li>
<li>Upload the content to your server</li>
<li>Create the video tag using the Shaka Player or Dash.js</li>
</ol>
<p>The process assumes that you’ve already encoded the videos to your target bit rate(s).</p>
<p><h2 id="packager">Packaging the video</h2></p>
<figure class="image-left">
<img src="https://github.com/google/shaka-packager/raw/master/docs/shaka-packager.png" alt="">
<figcaption>Shaka Packager, what we'll use to create the DASH Manifest</figcaption></figure>
<p><a href="https://github.com/google/shaka-packager/">Shaka Packager</a> is a tool developed by Google to create DASH manifest for our content. It will also create separate streams for audio and video.</p>
<p>In the example we’ll work with in these sections we’ll generate a manifest three diferent versions of the same video. <strong><em>Shaka Packager will not encode the video… that’s your job and it should be done before we start working in packaging and playing DASH content</em></strong>.</p>
<pre><code class="language-bash">path/to/packager \
input=media/SavingLight.mp4,stream=audio,output=audio.mp4 \
input=media/SavingLight.mp4,stream=video,output=video.mp4 \
input=media/SavingLight-baseline.mp4,stream=audio,output=audio-baseline.mp4 \
input=media/SavingLight-baseline.mp4,stream=video,output=video-baseline.mp4 \
input=media/SavingLight-high.mp4,stream=audio,output=audio-high.mp4 \
input=media/SavingLight-high.mp4,stream=video,output=video-high.mp4 \
--mpd_output example.mpd
</code></pre>
<p>If you’re comfortable compiling tools manually you can clone the Shaka Packager <a href="https://github.com/google/shaka-packager">Github Repository</a> and compile the tools following the instructions in the README file.</p>
<p><h3 id="manifest">The DASH Manifest</h3></p>
<p>One of the files produced by the Packager is the DASH manifest file. It is an XML file that describes the audio and video tracks that make up the video separately from one another.</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!--
  Generated with https://github.com/google/shaka-packager
  version 593f513c83-release--&gt;
&lt;MPD xmlns=&quot;urn:mpeg:dash:schema:mpd:2011&quot;
     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
     xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;
     xsi:schemaLocation=&quot;urn:mpeg:dash:schema:mpd:2011 DASH-MPD.xsd&quot;
     xmlns:cenc=&quot;urn:mpeg:cenc:2013&quot;
     profiles=&quot;urn:mpeg:dash:profile:isoff-on-demand:2011&quot;
     minBufferTime=&quot;PT2S&quot;
     type=&quot;static&quot;
     mediaPresentationDuration=&quot;PT355.614S&quot;&gt;
  &lt;Period id=&quot;0&quot;&gt;
    &lt;AdaptationSet id=&quot;0&quot; contentType=&quot;video&quot; width=&quot;1920&quot; maxHeight=&quot;1080&quot;
                   frameRate=&quot;90000/3754&quot;&gt;
      &lt;Representation id=&quot;0&quot; bandwidth=&quot;1778582&quot;
                      codecs=&quot;avc1.640028&quot;
                      mimeType=&quot;video/mp4&quot;
                      sar=&quot;1:1&quot;
                      height=&quot;1080&quot;&gt;
        &lt;BaseURL&gt;video.mp4&lt;/BaseURL&gt;
        &lt;SegmentBase indexRange=&quot;816-1231&quot; timescale=&quot;90000&quot;&gt;
          &lt;Initialization range=&quot;0-815&quot;/&gt;
        &lt;/SegmentBase&gt;
      &lt;/Representation&gt;
      &lt;Representation id=&quot;1&quot; bandwidth=&quot;2261351&quot;
                      codecs=&quot;avc1.640028&quot;
                      mimeType=&quot;video/mp4&quot;
                      sar=&quot;1:1&quot;
                      height=&quot;800&quot;&gt;
        &lt;BaseURL&gt;video-high.mp4&lt;/BaseURL&gt;
        &lt;SegmentBase indexRange=&quot;817-1208&quot; timescale=&quot;90000&quot;&gt;
          &lt;Initialization range=&quot;0-816&quot;/&gt;
        &lt;/SegmentBase&gt;
      &lt;/Representation&gt;
      &lt;Representation id=&quot;2&quot; bandwidth=&quot;2606321&quot;
                      codecs=&quot;avc1.42c028&quot;
                      mimeType=&quot;video/mp4&quot;
                      sar=&quot;1:1&quot;
                      height=&quot;800&quot;&gt;
        &lt;BaseURL&gt;video-baseline.mp4&lt;/BaseURL&gt;
        &lt;SegmentBase indexRange=&quot;815-1218&quot; timescale=&quot;90000&quot;&gt;
          &lt;Initialization range=&quot;0-814&quot;/&gt;
        &lt;/SegmentBase&gt;
      &lt;/Representation&gt;
    &lt;/AdaptationSet&gt;
    &lt;AdaptationSet id=&quot;1&quot; contentType=&quot;audio&quot; subsegmentAlignment=&quot;true&quot;&gt;
      &lt;Representation id=&quot;3&quot; bandwidth=&quot;127078&quot;
                      codecs=&quot;mp4a.40.2&quot;
                      mimeType=&quot;audio/mp4&quot;
                      audioSamplingRate=&quot;44100&quot;&gt;
        &lt;AudioChannelConfiguration
        schemeIdUri=&quot;urn:mpeg:dash:23003:3:audio_channel_configuration:2011&quot;
        value=&quot;2&quot;/&gt;
        &lt;BaseURL&gt;audio.mp4&lt;/BaseURL&gt;
        &lt;SegmentBase indexRange=&quot;745-1208&quot; timescale=&quot;44100&quot;&gt;
          &lt;Initialization range=&quot;0-744&quot;/&gt;
        &lt;/SegmentBase&gt;
      &lt;/Representation&gt;
      &lt;Representation id=&quot;4&quot; bandwidth=&quot;156471&quot;
                      codecs=&quot;mp4a.40.2&quot;
                      mimeType=&quot;audio/mp4&quot;
                      audioSamplingRate=&quot;44100&quot;&gt;
        &lt;AudioChannelConfiguration
        schemeIdUri=&quot;urn:mpeg:dash:23003:3:audio_channel_configuration:2011&quot;
        value=&quot;2&quot;/&gt;
        &lt;BaseURL&gt;audio-high.mp4&lt;/BaseURL&gt;
        &lt;SegmentBase indexRange=&quot;745-1208&quot; timescale=&quot;44100&quot;&gt;
          &lt;Initialization range=&quot;0-744&quot;/&gt;
        &lt;/SegmentBase&gt;
      &lt;/Representation&gt;
      &lt;Representation id=&quot;5&quot; bandwidth=&quot;156471&quot;
                      codecs=&quot;mp4a.40.2&quot;
                      mimeType=&quot;audio/mp4&quot;
                      audioSamplingRate=&quot;44100&quot;&gt;
        &lt;AudioChannelConfiguration
        schemeIdUri=&quot;urn:mpeg:dash:23003:3:audio_channel_configuration:2011&quot;
        value=&quot;2&quot;/&gt;
        &lt;BaseURL&gt;audio-baseline.mp4&lt;/BaseURL&gt;
        &lt;SegmentBase indexRange=&quot;745-1208&quot; timescale=&quot;44100&quot;&gt;
          &lt;Initialization range=&quot;0-744&quot;/&gt;
        &lt;/SegmentBase&gt;
      &lt;/Representation&gt;
    &lt;/AdaptationSet&gt;
  &lt;/Period&gt;
&lt;/MPD&gt;
</code></pre>
<p><h2 id="captions">Captions</h2></p>
<p>Subtitles and captions are also part of the packaging process. The example belows takes the movie Sintel and splits it into audio and video streams and adds an english caption track.</p>
<pre><code class="language-bash">packager \
  input=sintel.mp4,stream=audio,output=sintel_audio.mp4 \
  input=sintel.mp4,stream=video,output=sintel_video.mp4 \
  input=sintel_english_input.vtt,stream=text,output=sintel_english.vtt \
--mpd_output sintel_vod.mpd
</code></pre>
<p><h2 id="player-shaka">Playing content: Shaka Player</h2></p>
<figure>
<img src="https://github.com/google/shaka-player/raw/master/docs/shaka-player-logo.png" alt="">
<figcaption>Shaka Player, the player we'll use for this project</figcaption>
</figure>
<p><a href="https://github.com/google/shaka-player">Shaka Player</a> is the playback component of the Shaka ecosystem. Also developed by Google and open sourced on <a href="https://github.com/google/shaka-player">Github</a>.</p>
<p>If you’re used to HTML5 the way you add DASH video is a little more complicated than you’re used to. The process is:</p>
<p>First we create a simple HTML page with a video element. In this page we make sure that we add thescripts we need:</p>
<ul>
<li>The shaka-player script</li>
<li>The script for our application</li>
</ul>
<p>The <code>video</code> element is incomplete on purpose. We will add the rest of the video in the script later on.</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;!-- Shaka Player compiled library: --&gt;
    &lt;script src=&quot;path/to/shaka-player.compiled.js&quot;&gt;&lt;/script&gt;
    &lt;!-- Your application source: --&gt;
    &lt;script src=&quot;video.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;video id=&quot;video&quot;
           width=&quot;640&quot;
           poster=&quot;media/SavingLight.jpg&quot;
           controls autoplay&gt;&lt;/video&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>We’ll break the script into three parts:</p>
<ul>
<li>Application init</li>
<li>Player init</li>
<li>Error handler and event listener</li>
</ul>
<p>We initialize the application by installing the polyfills built into the Shaka player to make sure that all the supported players behave the same way and that there won’t be any unexpected surprises later on.</p>
<p>The next step is to check if the browser is supported using the built in <code>isBrowserSupported</code> check. If the browsers supports DASH then we initialize the player by calling <code>initPlayer()</code> otherwise we log the error to console.</p>
<pre><code class="language-javascript">var manifestUri = 'media/example.mpd';

function initApp() {
  // Install built-in polyfills to patch browser incompatibilities.
  shaka.polyfill.installAll();

  // Check to see if the browser supports the basic APIs Shaka needs.
  if (shaka.Player.isBrowserSupported()) {
    // Everything looks good!
    initPlayer();
  } else {
    // This browser does not have the minimum set of APIs we need.
    console.error('Browser not supported!');
  }
}
</code></pre>
<p>Initializing the player is the meat of the process and will take serval different steps.</p>
<p>We create variables to capture the video element using <code>getElementById</code> and the player by assigning a new instance of <code>Shaka.Player</code> and attach it to the video element.</p>
<p>We then attach the player to the window object to make it easier to access the console.</p>
<p>Next we attach the error event handler to the <code>onErrorEvent</code> function defined later in the script. Positioning doesn’t matter as far as Javascript is concerned.</p>
<p>The last step in this function is to try and load a manifest using a promise. If the promise succeeds then we log it to console otherwise the <code>catch</code> tree of the promise chain is executed and runs the <code>onError</code> function (which is different than <code>onErrorEvent</code> discussed earlier).</p>
<pre><code class="language-javascript">function initPlayer() {
  // Create a Player instance.
  var video = document.getElementById('video');
  var player = new shaka.Player(video);

  // Attach player to the window to make it easy to access in the JS console.
  window.player = player;

  // Listen for error events.
  player.addEventListener('error', onErrorEvent);

  // Try to load a manifest.
  // This is an asynchronous process.
  player.load(manifestUri).then(function() {
    // This runs if the asynchronous load is successful.
    console.log('The video has now been loaded!');
  }).catch(onError);  // onError is executed if the asynchronous load fails.
}
</code></pre>
<p>The last part of the script is to create the functions for errors (<code>onErrorEvent</code> and <code>onError</code>)</p>
<p>Finally we attach the <code>initApp()</code> function to the <code>DOMContentLoaded</code> event.</p>
<pre><code class="language-javascript">function onErrorEvent(event) {
  // Extract the shaka.util.Error object from the event.
  onError(event.detail);
}

function onError(error) {
  // Log the error.
  console.error('Error code', error.code, 'object', error);
}

document.addEventListener('DOMContentLoaded', initApp);
</code></pre>
<p>If everything works out OK we should have a video playing on screen.</p>
<p>There is a <a href="https://shaka-player-demo.appspot.com/demo/">full example</a> available to show how the player works.  We’ve covered only the player’s basic functionality; there’s additional capabilities like casting to an Android Play device and playing your content on your TV… I’m  more concerned with getting the video working.</p>
<p><h2 id="player-dashjs">Playing content: Dash.js</h2></p>
<figure>
<img src="https://cloud.githubusercontent.com/assets/2762250/7824984/985c3e76-03bc-11e5-807b-1402bde4fe56.png" alt="" width="400">
<figcaption>Dash.js is the reference implementation for MPEG-DASH</figcaption>
</figure>
<p><a href="https://github.com/Dash-Industry-Forum/dash.js">Dash.js</a> is the reference DASH implementation, meaning this is the technology that they use to validate and demonstrate the different part of the specification and what they offer developers and implementers to use as the basis of their own player software.</p>
<p>The first way to use Dash.js is to manually initialize the player and attach it to a video element already in the page. It is possible to also create the video element programmatically and then assign it to the player.</p>
<p>The standard setup method uses javascript to initialize and provide video details to dash.js. MediaPlayerFactory provides an alternative declarative setup syntax.</p>
<p><h3 id='dashjs-standard'>Standard Setup</h3></p>
<p>Using the same files that we used to create the Shaka demo we create the Dash.js video using code like the one below. In this page the script initializes the player and attaches it to the element with the id of video2 (<code>#video2</code>)</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
      video {
        width: 640px;
        height: 360px;
      }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div&gt;
    &lt;video id=&quot;video2&quot; poster=&quot;media/SavingLight.jpg&quot; controls&gt;&lt;/video&gt;
  &lt;/div&gt;

  &lt;script src=&quot;http://cdn.dashjs.org/latest/dash.all.min.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    (function(){
      var url = &quot;media/example.mpd&quot;;
      var player = dashjs.MediaPlayer().create();
      player.initialize(document.querySelector(&quot;#video2&quot;), url, true);
    })();
  &lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><h3 id="dashjs-factory">MediaPlayerFactory</h3></p>
<p>An alternative way to build a Dash.js player in your web page is to use the <code>MediaPlayerFactory</code>. The MediaPlayerFactory will automatically instantiate and initialize the MediaPlayer module on appropriately tagged video elements.</p>
<p>Create a <code>video</code> element somewhere in your html and provide the path to your mpd file as src. Also ensure that your video element has the <code>data-dashjs-player</code> attribute on it. An example using the <code>MediaPlayerFactory</code> looks like this:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script src=&quot;http://cdn.dashjs.org/latest/dash.all.min.js&quot;&gt;&lt;/script&gt;
    &lt;style&gt;
      video {
        width: 640px;
        height: 360px;
      }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div&gt;
    &lt;video data-dashjs-player src=&quot;media/example.mpd&quot; controls&gt;&lt;/video&gt;
  &lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><h2 id="conclusion">Conclusion</h2></p>
<p>Dash works but it requires a lot of work upfront to make the technology work as intended for the use cases use the technology for. The demos cover some of the most basic use cases for video on demand; we have not considered live streams or encrypted video.</p>
<p>As with many things on the web there is no ‘one size fits all’ solution. DASH works and it provides awesome capabilties but with those capabilities come additional cost for storage and delivery. In the example I used for this project used three streams each for audio and video and the weigh between 79 and 115MB for the video stream and  betwee 5 and 7MB per audio stream. The more bitrates you add the more you have to consider storage costs.</p>
<p>Video is an awesome tool but one that requires a lot of prep work up front for it to be an effective tool.</p>
<p><h2 id='demo-notes'>Notes about the demo repository</h2></p>
<p>All the code examples in this post are available in the <a href="https://github.com/caraya/dash-demo">dash-demo</a> Github repository. To store the mp4 content, some of which is over 100mb in size, we’ve set the repo with <a href="https://git-lfs.github.com/">GIT LFS</a> to handle the large files; this will get around Github’s file size limitation.</p>
<p>A brief summary of the files:</p>
<ul>
<li><a href="html5-video.html">html5-video.html</a> is a traditional HTML5 video tag using MP4, WebM and OGG video</li>
<li><a href="index.html">index.html</a> uses the Shaka Player to play DASH video</li>
<li><a href="dashjs.html">dashjs.html</a> uses Dash.js’s MediaPlayerFactory method</li>
<li><a href="dashjs2.html">dashjs2.html</a> uses Dash.js’s traditional method</li>
</ul>


<!-- <script src="../paged-media/highlight/highlight.pack.js"></script> -->
<script src="../paged-media/prism/prism.js"></script>
</body>
</html>