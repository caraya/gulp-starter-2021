<html lang="en" dir="ltr" class="no-js lazy">

<head>
  <!--<link rel="stylesheet" href="ccs/github.css">-->
  <link rel="stylesheet" href="css/normalize.css">
  <link rel="stylesheet" href="css/main.css">
  <link rel="stylesheet" href="css/image-load.css">
  <link rel="stylesheet" href="css/video-load.css">
  <link rel="stylesheet" href="css/prism.css">
  <!-- <script async src="scripts/menu.js"></script> -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">


  <title></title>
</head>

<body>
<article class="container">
  <h1>My minimal toolkit for development</h1>
<p>The argument about tool overload is not a new one. There have been many discussions over the years about what
framework is better, what language is better, whether you should use Ruby on Rails versus Angular, SASS instead of
LESS or Compass instead of plain SASS and even whether you should use SASS syntax over SCSS or vice versa.</p>
<p>I’ve been working with web technologies since before we had Javascript and CSS. I subscribe to the school that says
learn the basics and then jumpt into the fancy advanced stuff or in this case, paraphrasing Addy Osmani: <code>first do it, then do it right, then do it better</code> and then move on to the next thing.</p>
<p>For me that means: Learn how to use HTML, CSS and vanilla Javascript before jumping into whatever framework or
library is popular at the moment.</p>
<h2>Basic Infrastructure and build system installation and configuration</h2>
<p>To start we’ll define these core tools:</p>
<ul>
<li>Gulp as my task runner</li>
<li>ESLint as my Javascript Code Quality checker</li>
<li>Babel as my transpiler</li>
<li>Accessibility evaluation</li>
<li>Ruby SASS as my SASS compiler / interpreter</li>
</ul>
<p>Rather than have all the tools available right away we’ll build the infrastructure based on what we need to do.</p>
<p>In addition we have a few optional libraries and dependencies.</p>
<ul>
<li>Polymer as my development framework</li>
<li>Typescript as a second source of scripts and functionality</li>
</ul>
<p>We’ll discuss the optional elements later.</p>
<p>Before we start we need to initialize the node <code>package.json</code> file.</p>
<pre><code class="language-bash">npm init
</code></pre>
<blockquote>
<p>Note that the tasks described below are just the tasks. If you want to see the full Gulpfile.js, see the <a href="gulpfile.js">full
Gulpfile</a> in the associated Github repository.</p>
</blockquote>
<h3>Gulp</h3>
<p>When I started looking at modern development Grunt was the favorite (and perhaps the only) task runner available. I
moved to Gulp because I found it easier to work with (you can create custom task easier than you can in Grunt) and
because Polymer was using Gulp on their build system.</p>
<p>After complaining for a while I realized the advantages of Gulp both in terms of configuration and in terms of
extensibility (something I still don’t do much of). Tasks in Grunt are very procedural and, as a result,</p>
<pre><code class="language-bash">npm install -g gulp
npm install --save-dev gulp 
</code></pre>
<h3>ESLint</h3>
<p>When I first started I used a combination of JSHint and JSCS to keep my code clean and the syntax working. When JSCS
announced their merging with ESLint I decided it was time to change.</p>
<p>ESlint has presets available. I’ve chosen to use Google’s preset, both because it was the requirement when working on
Progressive Web Applications at Google and because it matches a lot of what I do when writng Javascript.</p>
<pre><code class="language-bash">npm install -g eslint
npm install --save-dev eslint 
npm install --save-dev eslint-config-google
</code></pre>
<h3>Babel and Presets</h3>
<p>Babel (formerly known as 6to5) transpiles ES2015 and later into ES5 that can be used in modern browsers. In addition
to installing the Command Line Tool we need to install presets to add specific features that we want to work with.</p>
<p>Each preset contains the features that made it to stage 3 for that given version of EcmaScript.  This will allow
developers to work with the features of each version of the ECMAScript standard before they are fully implemented in
browsers.</p>
<p>Some people may argue that we don’t need the <code>es2015</code> preset because all modern browsers are above 95% support
according to Kangax’s <a href="http://kangax.github.io/compat-table/es6/">ES2015 compatibility table</a>. That is true only doe</p>
<p>For <a href="preset-es2015">preset-es2015</a> the supported plugins are:</p>
<ul>
<li>check-es2015-constants</li>
<li>transform-es2015-arrow-functions</li>
<li>transform-es2015-block-scoped-functions</li>
<li>transform-es2015-block-scoping</li>
<li>transform-es2015-classes</li>
<li>transform-es2015-computed-properties</li>
<li>transform-es2015-destructuring</li>
<li>transform-es2015-duplicate-keys</li>
<li>transform-es2015-for-of</li>
<li>transform-es2015-function-name</li>
<li>transform-es2015-literals</li>
<li>transform-es2015-modules-commonjs</li>
<li>transform-es2015-object-super</li>
<li>transform-es2015-parameters</li>
<li>transform-es2015-shorthand-properties</li>
<li>transform-es2015-spread</li>
<li>transform-es2015-sticky-regex</li>
<li>transform-es2015-template-literals</li>
<li>transform-es2015-typeof-symbol</li>
<li>transform-es2015-unicode-regex</li>
<li>transform-regenerator</li>
</ul>
<p>For <a href="https://babeljs.io/docs/plugins/preset-es2016/">preset-2016</a> the supported plugin is:</p>
<ul>
<li>transform-exponentiation-operator</li>
</ul>
<p>For <a href="http://babeljs.io/docs/plugins/preset-es2017">preset-2017</a> the currently supported plugins are:</p>
<ul>
<li>syntax-trailing-function-commas</li>
<li>transform-async-to-generator</li>
</ul>
<p>Note that there may be additional transformations that will still make it to the ES2017 specification.</p>
<pre><code class="language-bash">npm install -save-dev babel-cli 
npm install --save-dev babel-preset-es2015
npm install --save-dev babel-preset-es2016
npm install --save-dev babel-preset-es2017
</code></pre>
<h3>Accessibility</h3>
<p>Skipping or not paying attention to accessibility is easy. I got a harsh lesson when I was working on a Polymer
project and got absolutely no keyboard navigation. To make it harder to ignore I’ve created a task using
<a href="https://addyosmani.com/a11y/">a11y</a> to evaluate accessibility as part of the build process.</p>
<p>The pluin may change (it hasn’t been updated in a while) but the underlying tool will not.</p>
<pre><code class="language-bash">npm install --save-dev gulp-a11y
</code></pre>
<h3>Installing additional Gulp plugins</h3>
<p>There are plugins we’ll use throughout multiple tasks so rather than install them multiple times we’ll install them
once here and not have to worry about it again.</p>
<p><code>gulp-sourcemaps</code> generates sourcemaps for both CSS Stylesheets and JS scripts. This allows Dev Tools on your browser
to translate locations in a minified file to the original script, making it easier to debug and troubleshoot
problems in your code.</p>
<p><code>gulp-sizes</code> will give you the size of the completed task.</p>
<p><code>gulp-sequence</code> allows gulp to run tasks synchronously as opposed to de default to run as many task as
possible concurrently.</p>
<p><code>del</code> provides a delete function that can be incorporated into other tasks. We’ll use it to create a clean task to
reset our working directory.</p>
<p><code>gulp-load-plugins</code> loads all packages defined in <code>package.json</code> and assigns them to an object of your choice,
usually <code>$</code>. The limitation is that the package must start with the string <code>gulp-</code> for load-plugins to pick it up.</p>
<pre><code class="language-bash">npm install --save-dev gulp-sourcemaps
npm install --save-dev gulp-sizes
npm install --save-dev gulp-sequence
npm install --save-dev del
npm install --save-dev gulp-load-plugins
</code></pre>
<h3>editorconfig</h3>
<p>It also doesn’t hurt to have an <a href="http://editorconfig.org/">editorconfig</a> configuration file in your project. This
will take care of indenting and line endings for you. It can be configured to treat different languages differently
and it even works with specific files or globs for directories.</p>
<p>In the example below (taken from the editorconfig site) we work with Javascript and Python files with different
indentations and charsets. It will also take care of converting all the line endings to Unix and adding an extra line
at the end of the file as required by the Google ESLint rules.</p>
<pre><code class="language-ini"># EditorConfig is awesome: http://EditorConfig.org

# top-most EditorConfig file
root = true

# Unix-style newlines with a newline ending every file
[*]
end_of_line = lf
insert_final_newline = true

# Matches multiple files with brace expansion notation
# Set default charset for Javascript and Python
[*.{js,py}]
charset = utf-8

# 4 space indentation for Python files
[*.py]
indent_style = space
indent_size = 4

# Indentation override for all JS
[**/*.js]
indent_style = space
indent_size = 2
</code></pre>
<h2>Configuring the basics</h2>
<p>Now that we’ve installed the basic tools we need to create configuration files for them. These configurations will
make use of the tools we instaled in the previous step and make sure we stay clean and we can concetrate on the work
we want to do.</p>
<h3>Configuring Babel</h3>
<p><code>.babelrc</code> is the configuration file for Babel. Ours is as simple as it can be: we use the presets for es2015, 2016
and 2017.  We’ll repeat this configuration in the Babel task but it’s still good to have it since there may be
situations when we run Babel from the command line.</p>
<pre><code class="language-json">{
  &quot;presets&quot;: [
    &quot;es2015&quot;,
    &quot;es2016&quot;,
    &quot;es2017&quot;
  ]
}
</code></pre>
<h3>ESLint configuration</h3>
<p><code>.eslintrc.json</code> is the primary configuration file for ESLint. In it we have 3 areas:</p>
<ul>
<li><strong>extends</strong> tells eslints which plugins to extend from. In this case the base recommended plugin as well as Google’s
eslint extensions and rules</li>
<li><strong>env</strong> indicates what environments to accept. In this example we use es6, browser, Node, jQuery and Mocha</li>
<li><strong>rules</strong> tells ESLint what rules we want to override. Some of these overrides work in conjunction with the rules
we set up in our <code>.editorconfig</code> configuration file</li>
</ul>
<pre><code class="language-json">{
    &quot;extends&quot;: [
        &quot;recommended&quot;,
        &quot;google&quot;
    ],
    &quot;env&quot;: {
        &quot;es6&quot;: true,
        &quot;browser&quot;: true,
        &quot;node&quot;: true,
        &quot;jquery&quot;: true,
        &quot;mocha&quot;: true
    },
    &quot;rules&quot;: {
        &quot;indent&quot;: [&quot;error&quot;, 2],
        &quot;linebreak-style&quot;: [&quot;error&quot;, &quot;unix&quot;],
        &quot;quotes&quot;: [&quot;error&quot;, &quot;single&quot;],
        &quot;no-cond-assign&quot;: [&quot;error&quot;, &quot;always&quot;],
        &quot;no-console&quot;: &quot;off&quot;
    }
}
</code></pre>
<h2>Layering on top of the basics</h2>
<p>Now that I have all the tasks set up and configured we can start building the tasks for Babel and ESLint. Because
we’ve installed all the necessary plugins we’ll just look at the tasks that will run as part of our <code>gulpfile.js</code>.</p>
<h3>Babel Gulp Task</h3>
<p>The Babel task will perform the following steps</p>
<ul>
<li>Take all the files under <code>src/js</code> that end with <code>.js</code> to any directory depth</li>
<li>Initialize the sourcemaps engine</li>
<li>Run Babel using the indicated presets</li>
<li>Write the sourcemap</li>
<li>Write the ES5 transpiled code to the destination directory (<code>dest/js</code>)</li>
</ul>
<pre><code class="language-javascript">gulp.task('babel', function() {
  return gulp.src('src/js/**/*.js')
    .pipe($.sourcemaps.init())
    .pipe($.babel({
      presets: ['es2015', 'es2016', 'es2017']
    }))
    .pipe($.sourcemaps.write('.'))
    .pipe(gulp.dest('dest/js/'))
    .pipe($.size({
      pretty: true,
      title: 'Babel'
    }));
});
</code></pre>
<h3>ESLinting your scripts</h3>
<p>ESLint is a combination of Linter and Quality control tool. It took the place of both JSHint and JSCS once the later
merged into ESLint.  The task below runs ESLint on all the Javascript files on your application except for the
<code>node_modules</code> tree. For each file it logs information to console about warnings, errors and how many messages it
generated.</p>
<pre><code class="language-javascript">gulp.task('eslint', function () {
  gulp.src(['**/*.js','!node_modules/**'])
    .pipe(eslint({
       configFile: '.eslintrc.json'
    }))
    .pipe(eslint.result(function(result) {
        console.log('ESLint result: ' + result.filePath);
        console.log('# Messages: ' + result.messages.length);
        console.log('# Warnings: ' + result.warningCount);
        console.log('# Errors: ' + result.errorCount);
    }));
});
</code></pre>
<h3>Accessibility</h3>
<p>To keep myself honest when it comes to accessibility I created</p>
<pre><code class="language-javascript">gulp.task('audit', function () {
  return gulp.src('./**/*.html')
    .pipe(a11y())
    .pipe(a11y.reporter());
});
</code></pre>
<h2>Purpose tasks</h2>
<p>Most of Gulp’s (and other task runners) workflow is to perform repetitive of time consuming tasks or tasks that need
to be continuously repeated during development. The tasks below represent some of these activities.</p>
<p>Each of the tasks include a list of Gulp plugins to install and the actual task we include in the <code>gulpfile.js</code> that
we’ll run to complete the tasks.</p>
<blockquote>
<p>Note that the tasks described below are just the tasks. If you want to see the full Gulpfile.js, see the <a href="gulpfile.js">full
Gulpfile</a> in the associated Github repository.</p>
</blockquote>
<h3>Development Server and Content Preview</h3>
<p>For our development server we’ll use <a href="https://www.browsersync.io/">Browsersync</a>. It allows multiple synchronized
tests from the same content (we can open Safari, Chrome and Firefox and whenever files change, all the browsers will
be notified).</p>
<p>The <code>connect-history-api-fallback</code> deals with  the fact that Single Page Applications (SPA) typically only utilise one
index file that is accessible by web browsers: usually index.html. Navigation in the application is then commonly
handled using JavaScript with the help of the <a href="http://www.w3.org/html/wg/drafts/html/master/single-page.html#the-history-interface">HTML5 History API</a>.
This results in issues when the user hits the  refresh button or is directly accessing a page other than  the landing
page, e.g. /help or /help/online as the web server bypasses the index file to locate the file at this  location. As
your application is a SPA, the web server will fail trying to retrieve the file and return a 404 - Not Found message
to the user.</p>
<p>While not all the projects I work in are SPAs it’s good to have it.</p>
<pre><code class="language-bash">npm install --save-dev browser-sync
npm install --save-dev connect-history-api-fallback
</code></pre>
<p>The task performs the following actions:</p>
<ul>
<li>Configures Browsersync</li>
<li>Adds the snippet string to match and the function to insert the snippet into the page</li>
<li>Has a commented out option to use HTTPS</li>
<li>Configures the base directories for the server</li>
<li>Specifies the middleware to use (historyApiFallback)</li>
<li>Set up watches to reload the page when something changes.
<ul>
<li>If the SASS changes we run the sass compilation and the CSS processing tasks before reloading</li>
</ul>
</li>
</ul>
<pre><code class="language-javascript">var reload = browserSync.reload;

gulp.task('serve', function() {
  browserSync({
    port: 2509,
    notify: false,
    logPrefix: 'ATHENA',
    snippetOptions: {
      rule: {
        match: '&lt;span id=&quot;browser-sync-binding&quot;&gt;&lt;/span&gt;',
        fn: function (snippet) {
          return snippet;
        }
      }
    },
    // Run as an https by uncommenting 'https: true'
    // This uses an unsigned certificate which on first access
    // will present a certificate warning in the browser.
    // https: true,
    server: {
      baseDir: ['.tmp', 'dest'],
      middleware: [historyApiFallback()]
    }
  });

  gulp.watch(['app/**/*.html'], reload);
  gulp.watch(['app/css/**/*.scss'], ['sass', 'processCSS', reload]);
  gulp.watch(['app/images/**/*'], reload);
});
</code></pre>
<h3>SASS Conversion and CSS Processing</h3>
<p>I’ve chosen to use the SCSS version of SASS as my primary stylesheet language because of its flexibility and the
programming-like structures available. It deviates from the KISS principle but the features make it a worthy tradeoff.</p>
<p>SASS was originally developed as a Ruby library and is available as a Ruby Gem. This introduces an additional
dependency but the Node version (libsass) still chokes on older projects so I’m ok with using the Ruby version.</p>
<p>The SCSSLint library also depends on Ruby</p>
<p>To install the Ruby dependencies, run the following commands</p>
<pre><code class="language-bash">gem install sass
gem install scss_lint
</code></pre>
<p>Then install the node packages as usual:</p>
<pre><code class="language-bash">npm install --save-dev gulp-ruby-sass
# If you don't want to depend on Ruby run the following command instead
npm install --save-dev gulp-sass
# If you don't want to depend on Ruby don't run the next two lines
npm install --save-dev scss-llint
npm install --save gulp-scss-lint-stylish2
npm install --save-dev autoprefixer
npm install --save-dev gulp-postcss

</code></pre>
<p>The <code>sass</code> task takes all the files in the path startinin the <code>scss</code> directory and do the following:</p>
<ul>
<li>Run SCSS lint to make sure there are no errors</li>
<li>Run the SASS compiker usin the expanded syntax</li>
</ul>
<pre><code class="language-javascript">gulp.task('sass', function() {
  return sass('app/scss/**/*.scss', { 
      sourcemap: true, 
      style: 'expanded'})
    .pipe($.scsslint({
      'reporterOutputFormat': 'Checkstyle'
     }))
    .pipe(gulp.dest('app/css/expanded'))
    .pipe($.size({
      pretty: true,
      title: 'SASS'
    }));
});
</code></pre>
<p>We are ready to process the resulting CSS.</p>
<p>We first set a variable with an array of the browser versions we want to auto prefix for. This was originally taken
from the Polymer Starter Kit gulpfile.</p>
<p>We then run the following tasks:</p>
<ul>
<li>Autoprefix the CSS using the browser versions defined in the <code>AUTOPREFIXER_BROWSERS</code> variable</li>
<li>CleanCSS to minimize the result</li>
</ul>
<pre><code class="language-javascript">var AUTOPREFIXER_BROWSERS = [
  'ie &gt;= 10',
  'ie_mob &gt;= 10',
  'ff &gt;= 30',
  'chrome &gt;= 34',
  'safari &gt;= 7',
  'opera &gt;= 23',
  'ios &gt;= 7',
  'android &gt;= 4.4',
  'bb &gt;= 10'
];

gulp.task('processCSS', function() {
  return gulp.src('src/css/**/*.css')
    .pipe($.sourcemaps.init())
    .pipe($.postcss([
      autoprefixer({ browsers: AUTOPREFIXER_BROWSERS })
    ]))
    .pipe(cleanCSS({
      advanced: false,
      aggressiveMerging: false,
      debug: true,
      keepBreaks: true,
      mediaMerging: false,
      processImport: false,
      rebase: false
    }))
    .pipe($.sourcemaps.write('.'))
    .pipe(gulp.dest('dist/css'))
    .pipe($.size({
      pretty: true,
      title: 'processCSS'
    }));
  });
</code></pre>
<h3>Creating images for responsive images elements</h3>
<p><a href="https://responsiveimages.org/">Responsive Images</a> deal with the fact that Sixty-two percent of the weight of the web
is images, and we’re serving more image bytes every day regardless of the device accessing our web content. This is
particularly important in  emerging markets where bandwidth is expensive and one 2MB page can take 20% of a user’s
monthly bandwidth or more.</p>
<p>There are different ways to create responsive images documented in many places. A List Apart’s <a href="http://alistapart.com/article/responsive-images-in-practice">Responsive Images in
Practice</a> and its <a href="http://alistapart.com/blog/post/article-update-dont-rely-on-default-sizes/">update</a> do<br />
a good job of explaining</p>
<p>The task creates a set of reponsive images for each of the PNG and JPG images in the images directory to any depth,
except for the images in the touch directory (we only need one version of each image in that directory). We currently
only create jpg images. We could take responsive images to the extreme and also generate <a href="https://www.sitepoint.com/webp-image-format/">webp</a>
versions for browsers that support the format.</p>
<p>This task does not create the markup we need to work with responsive images. For a more detailed look at responsive
images and the necessary markup, see <a href="https://publishing-project.rivendellweb.net/learning-about-responsive-images/">Learning abut responsive
images</a></p>
<pre><code class="language-javascript">gulp.task('processImages', function() {
  return gulp.src(
    [
      'app/images/**/*.{jpg, png}',
      '!app/images/touch/*.png'
    ])
    .pipe($.responsive({
      '*': [{
        // image-small.jpg is 200 pixels wide
        width: 200,
        rename: {
          suffix: '-small',
          extname: '.jpg'
        }
      }, {
        // image-small@2x.jpg is 400 pixels wide
        width: 200 * 2,
        rename: {
          suffix: '-small@2x',
          extname: '.jpg'
        }
      }, {
        // image-large.jpg is 480 pixels wide
        width: 480,
        rename: {
          suffix: '-large',
          extname: '.jpg'
        }
      }, {
        // image-large@2x.jpg is 960 pixels wide
        width: 480 * 2,
        rename: {
          suffix: '-large@2x',
          extname: '.jpg'
        }
      }, {
        // image-extralarge.jpg is 1280 pixels wide
        width: 1280,
        rename: {
          suffix: '-extralarge',
          extname: '.jpg'
        }
      }, {
        // image-extralarge@2x.jpg is 2560 pixels wide
        width: 1280 * 2,
        rename: {
          suffix: '-extralarge@2x',
          extname: '.jpg'
        }
      }, {
        // Global configuration for all images
        // The output quality for JPEG, WebP 
        // and TIFF output formats
        quality: 80,
        // Use progressive (interlace) scan 
        // for JPEG and PNG output
        progressive: true,
        // Skip enalrgement warnings
        skipOnEnlargement: false,
        // Strip all metadata
        withMetadata: true
      }]
    })
      .pipe(gulp.dest('dist/images')));
})
</code></pre>
<h3>Image compression</h3>
<p>There are times when using responsive images is overkill. Some times it’s enough to just reduce the size of an image
withough loosing quality. Imagemin will optimize SVG, JPG, PNG and GIF and, where appropriate, convert the image to
WebP.</p>
<pre><code class="language-bash">npm install --save-dev gulp-imagemin
npm install --save-dev gulp-svgmin
npm install --save-dev gulp-svgstore 
npm install --save-dev imagemin-mozjpeg
npm install --save-dev imagemin-webp
</code></pre>
<p>The task will take all the images in the <code>src/images/</code> directory tree and first pass them through imagemin using the
mozjpeg compressor and then convert them to WebP.</p>
<pre><code class="language-javascript">gulp.task('imagemin', function() {
  return gulp.src('src/images/**')
    .pipe(imagemin({
      progressive: true,
      svgoPlugins: [
        {removeViewBox: false},
        {cleanupIDs: false}
      ],
      use: [mozjpeg()]
    }))
    .pipe(webp({quality: 50})())
    .pipe(gulp.dest('dist/images'))
    .pipe($.size({
      pretty: true,
      title: 'imagemin'
    }));
});
</code></pre>
<h3>UNCSS</h3>
<p>When using the same CSS for multiple project it’s impossible not to bloat the libraries we use.</p>
<p>This is particularly true when using libraries like Bootstrap or Foundation with their big multipurpose scripts
which we seldom slim down, even when building custom versions of the libraries.</p>
<p>UNCSS will take one ore more CSS files and match it with all the content of one or more HTML files and produce a new
CSS style sheet with only the selectors used in the HTML files. This will definitely reduce the size of the CSS files
and make the site/app load faster.</p>
<p>In the example below, the bootstrap CSS was reduced to 11kb, a 10x reduction in its weight.</p>
<p><img src="https://camo.githubusercontent.com/6d7f74cf619eaaa1fe1c55feb2f796a6af504e72/68747470733a2f2f692e696d6775722e636f6d2f7568574d414c482e676966" alt="" /></p>
<pre><code class="language-javascript">gulp.task('uncss', function() {
  return gulp.src('app/css/**/*.css')
    .pipe($.concat('main.css'))
    .pipe($.uncss({
      html: ['index.html']
    }))
    .pipe(gulp.dest('dist/css/main.css'))
    .pipe($.size({
      pretty: true,
      title: 'Uncss'
    }));
});
</code></pre>

</article>
<!--
</div> -->
<script src="scripts/lazy-load.js"></script>
<script src="scripts/vendor/clipboard.min.js"></script>
<script src="scripts/vendor/prism.js"></script>
<script src="scripts/vendor/fontfaceobserver.js"></script>
<script src="scripts/load-fonts.js"></script>
<script src="scripts/lazy-load-video.js"></script>
</body>
</html>