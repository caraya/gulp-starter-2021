<html lang="en" dir="ltr" class="no-js lazy">

<head>
  <!--<link rel="stylesheet" href="ccs/github.css">-->
  <link rel="stylesheet" href="css/normalize.css">
  <link rel="stylesheet" href="css/main.css">
  <link rel="stylesheet" href="css/image-load.css">
  <link rel="stylesheet" href="css/video-load.css">
  <link rel="stylesheet" href="css/prism.css">
  <!-- <script async src="scripts/menu.js"></script> -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">


  <title></title>
</head>

<body>
<article class="container">
  <h1>Web Workers, How, Why, When</h1>
<p>Web Workers (workers for short) are a way to create multi-treaded applications in Javascript and get around the language’s single threaded application model.</p>
<p>According to <a href="https://dassur.ma/things/when-workers/">Surma</a>:</p>
<blockquote>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker">Web Workers</a>, also called “Dedicated Workers”, are JavaScript’s take on threads. JavaScript engines have been built with the assumption that there is a single thread, and consequently there is no concurrent access JavaScript object memory, which absolves the need for any synchronization mechanism. If regular threads with their shared memory model got added to JavaScript it would be disastrous to say the least. Instead, we have been given <a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker">Web Workers</a>, which are basically an entire JavaScript scope running on a separate thread, without any shared memory or shared values. To make these completely separated and isolated JavaScript scopes work together you have <a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage">postMessage()</a>, which allows you to trigger a message event in the other JavaScript scope together with the copy of a value you provide (copied using the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm">structured clone algorithm</a>).</p>
</blockquote>
<p>So, the idea is that we get a way to run computationally expensive tasks off the main execution thread, improving the application’s performance and responsiveness by making the main thread do less work.</p>
<p>In a script/module hosted in the main page, in this example using a script tag,  we create a worker and provide functions for it to communicate with the main thread.</p>
<pre><code class="language-html">&lt;script&gt;
const supportsWorker = 'Worker' in window;

if (!supportsWorker) {
    console.log('Web Workers not supported');
  // Implement a fallback strategy
} else {
    const worker = new Worker('echoWorker.js');
    const result = document.querySelector('#result');

    // post message to worker
    worker.postMessage('&lt;h1&gt;Message sent to the worker&lt;/h1&gt;');

    worker.onmessage = event =&gt; {
        result.innerHTML = event.data;
    }
}
&lt;/script&gt;
</code></pre>
<p><code>echoWorker</code> will send back whatever message it received from the main thread. It will do this by reacting to messages using the <code>onmessage</code> event and posting the content of the event back too the main thread using <code>postMessage</code>.</p>
<pre><code class="language-js">onmessage = (e) =&gt; {
  console.log('Echoing message we got from main script');
  postMessage(e.data);
};
</code></pre>
<p>The combination offers interesting posibilities an example that I found interesting is converting Markdown to HTML using a worker.</p>
<p>The code in the main page is similar to the echo example. The main difference is we’re sending a Markdown file in the postMessage to the worker and taking the result of processing that file as the result.</p>
<pre><code class="language-html">&lt;div id='result'&gt;&lt;/div&gt;
&lt;script&gt;
  const supportsWorker = 'Worker' in window;

  if (!supportsWorker) {
    // If the browser doesn't support workers bail
    console.log('Web Workers not supported');
  } else {
    // Create the worker
    const worker = new Worker('./markdownWorker.js');
    const result = document.querySelector('#result');

    // post message to worker with the file to use
    worker.postMessage('./content2.md');

    worker.onmessage = event =&gt; {
      result.innerHTML = event.data;
    }
  }
&lt;/script&gt;
</code></pre>
<p>I’ve broken the <code>markdownWorker.js</code> file into multiple sections to make the explanation easier.</p>
<p>The worker uses third-party resources via <a href="https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/importScripts">importScripts</a>. In this case we load the Remarkable Markdown Parser and the Highlight.js syntax highlighter.</p>
<pre><code class="language-js">importScripts(
  'https://cdn.jsdelivr.net/npm/remarkable@1.7.1/dist/remarkable.js',
  'https://cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js');
</code></pre>
<p>Everything that we want to react to happens inside the <code>onmessage</code> event.</p>
<p>We first create and configure a Remarkable instance. The highlight configuration uses Highlight.js to insert the hightlighting classes and attributes that will display the highlighted code.</p>
<pre><code class="language-js">self.onmessage = (event) =&gt; {
  const md = new Remarkable('full', {
    html: true,
    linkify: true,
    typographer: true,
    // Set highlight options for highlight.js
    highlight: function(str, lang) {
      if (lang &amp;&amp; hljs.getLanguage(lang)) {
        try {
          return hljs.highlight(lang, str).value;
        } catch (err) {}
      }

      try {
        return hljs.highlightAuto(str).value;
      } catch (err) {}

      return '';
    },
  });
</code></pre>
<p>The final element of the worker is a fetch promise chain. The chain does the following:</p>
<ol>
<li>It fetches the file indicated by <code>event.data</code></li>
<li>Converts the downloaded data into text</li>
<li>Renders the text file into Markdown using the Remarkable instance we defined earlier</li>
<li>Sends the data back to the main script using <code>postMessage</code></li>
</ol>
<p>If there is an error the catch block triggers and we report it to the console.</p>
<pre><code class="language-js">  fetch(event.data)
  .then((response) =&gt; {
    // Convert the response to text
    return response.text();
  })
  .then((content) =&gt; {
    let transformedSource = md.render(content);
    postMessage(transformedSource);
  })
  .catch((err) =&gt; {
    console.log('There\'s been a problem completing your request: ', err);
  });
};
</code></pre>
<h2>Some things to consider</h2>
<p>While workers have access to most APIs and features available to the main thread they are not fully equivalent.</p>
<p>The biggest issue, for me, is that you can’t directtly manipulate the DOM from inside Workers (since the global element is <code>DedicatedWorkerGlobalScope</code> and not the window global scope)</p>
<p>See <a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker/Functions_and_classes_available_to_workers">Functions and classes available to workers</a> for a list of functions and APIs that work inside a worker.</p>
<h2>Links and resources</h2>
<ul>
<li>MDN <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers">Using Web Workers</a></li>
<li><a href="https://dassur.ma/things/when-workers/">When should you be using Web Workers?</a></li>
<li>MDN <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers">Using Web Workers</a></li>
</ul>

</article>
<!--
</div> -->
<script src="scripts/lazy-load.js"></script>
<script src="scripts/vendor/clipboard.min.js"></script>
<script src="scripts/vendor/prism.js"></script>
<script src="scripts/vendor/fontfaceobserver.js"></script>
<script src="scripts/load-fonts.js"></script>
<script src="scripts/lazy-load-video.js"></script>
</body>
</html>